<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LOMswap</title>

<link rel="icon" type="image/x-icon" href="https://i.imgur.com/HddyTrv.jpeg">
<link rel="apple-touch-icon" href="https://i.imgur.com/HddyTrv.jpeg">
<link rel="shortcut icon" href="https://i.imgur.com/HddyTrv.jpeg">

<meta property="og:title" content="LOMswap - Conflux å»ä¸­å¿ƒåŒ–äº¤æ˜“æ‰€">
<meta property="og:description" content="åœ¨ Conflux eSpace ä¸Šäº¤æ˜“ LOM ä»£å¸">
<meta property="og:image" content="https://i.imgur.com/HddyTrv.jpeg">
<meta property="og:url" content="https://lom-dex.com">
<meta name="twitter:card" content="summary_large_image">

<meta http-equiv="Content-Security-Policy" 
      content="default-src 'self' https:;
               script-src 'self' https://cdn.jsdelivr.net 'unsafe-inline' 'unsafe-eval';
               style-src 'self' 'unsafe-inline';
               img-src 'self' https://i.imgur.com data:;
               connect-src 'self' https://*.confluxrpc.com wss: blob:;
               font-src 'self' data:;
               frame-src 'none';
               object-src 'none';">

<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<style>
/* å®Œæ•´çš„CSSæ ·å¼ä¿æŒä¸å˜ï¼Œä¸åŸå§‹ä»£ç å®Œå…¨ç›¸åŒ */
/* ä¸ºäº†èŠ‚çœç©ºé—´ï¼Œè¿™é‡Œçœç•¥å®Œæ•´çš„CSSæ ·å¼ï¼Œè¯·ä½¿ç”¨åŸå§‹ä»£ç ä¸­çš„CSSéƒ¨åˆ† */
</style>
</head>
<body>
<!-- é¡¹ç›®ä»‹ç»å¼¹çª— -->
<div class="project-intro-overlay" id="projectIntroOverlay">
  <div class="project-intro-card">
    <button class="project-intro-close-btn" id="projectIntroCloseBtn">Ã—</button>
    
    <div class="project-intro-header">
      <div class="project-intro-logo"></div>
      <h1 class="project-intro-title">é¾™è„‰ LOM</h1>
      <div class="project-intro-subtitle">Confluxç”Ÿæ€æ ¸å¿ƒèµ„äº§</div>
      <div class="project-intro-slogan">å…±è¯†åˆ›é€ ä»·å€¼</div>
    </div>
    
    <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
  </div>
</div>

<!-- ä¸»åº”ç”¨ç•Œé¢ -->
<div class="app">
  <!-- å¤´éƒ¨ -->
  <div class="header">
    <div class="logo-container" id="logoContainer">
      <div class="logo-img"></div>
      <div class="logo-text">LOMswap</div>
    </div>
    <div class="header-buttons">
      <button class="btn" id="langBtn">EN</button>
      <button class="btn" id="walletBtn">è¿æ¥é’±åŒ…</button>
    </div>
  </div>

  <!-- æ ‡ç­¾é¡µ -->
  <div class="tab-container">
    <div class="tabs">
      <button class="tab-btn active" data-tab="swap">å…‘æ¢</button>
      <button class="tab-btn" data-tab="liquidity">æµåŠ¨æ€§</button>
      <button class="tab-btn" data-tab="lpReward">LPå¥–åŠ±</button>
    </div>
  </div>

  <!-- å…‘æ¢é¡µé¢ -->
  <div class="tab-content active" id="swapTab">
    <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
  </div>
  
  <!-- æµåŠ¨æ€§é¡µé¢ -->
  <div class="tab-content" id="liquidityTab">
    <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
  </div>

  <!-- LPå¥–åŠ±é¡µé¢ -->
  <div class="tab-content" id="lpRewardTab">
    <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
  </div>

  <!-- é£é™©æç¤º -->
  <div class="risk-warning" id="riskWarning">
    <div class="risk-title">
      <span>âš ï¸</span>
      <span id="riskTitle">é£é™©æç¤º</span>
    </div>
    <div id="riskText">
      æœ¬åº”ç”¨ä»…ä½œä¸ºæŠ€æœ¯æ¼”ç¤ºï¼Œä¸æ„æˆä»»ä½•æŠ•èµ„å»ºè®®ã€‚åŠ å¯†è´§å¸å¸‚åœºæ³¢åŠ¨å·¨å¤§ï¼ŒæŠ•èµ„éœ€è°¨æ…ï¼Œè¯·ç†æ€§å¯¹å¾…æ•°å­—èµ„äº§äº¤æ˜“ã€‚
    </div>
  </div>

  <!-- é¡µè„š -->
  <div class="footer" id="footerText">LOMswap Â· Conflux eSpace</div>
</div>

<!-- ä»£å¸é€‰æ‹©å™¨æ¨¡æ€æ¡† -->
<div class="token-selector-modal" id="tokenSelectorModal">
  <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
</div>

<!-- æ·»åŠ æµåŠ¨æ€§æ¨¡æ€æ¡† -->
<div class="modal-overlay" id="addModal">
  <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
</div>

<!-- ç§»é™¤æµåŠ¨æ€§æ¨¡æ€æ¡† -->
<div class="modal-overlay" id="removeModal">
  <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
</div>

<!-- äº¤æ˜“çŠ¶æ€æç¤º -->
<div class="tx-status-overlay" id="txStatusOverlay">
  <!-- ... ä¿æŒåŸæœ‰HTMLç»“æ„ä¸å˜ ... -->
</div>

<script>
'use strict';

// ==================== ç»Ÿä¸€é…ç½® ====================
const APP_CONFIG = {
  CONTRACTS: {
    ROUTER: "0x62b0873055bf896dd869e172119871ac24aea305",
    LOM: "0xb4ca1cb2651a822bf65c614c880a26fd124932a3",
    WCFX: "0x14b2d3bc65e74dae1030eafd8ac30c533c976a9b",
    PAIR: "0x063128f4e6BDFBC693d03649000B6E4dA00Bec85",
    USDC: "0x6963efed0ab40f6c3d7bda44a05dcf1437c44372",
    AXCNH: "0x70BFD7F7eADF9b9827541272589A6B2Bb760aE2E",
    USDT0: "0xaf37e8b6c9ed7f6318979f56fc287d76c30847ff",
    CNHT0: "0xDEd1660192d4d82e7c0B628ba556861EdBB5CAda",
    AXCNH_USDT0_PAIR: "0x50b095DF7a8f856C6fA07fF89bcBC2dF8491A8df",
    LP_REWARD: "0x6Cbb8a3Eb043Bf7A04412F01096997609cc6D5a3"
  },
  TOKEN_LOGOS: {
    CFX: "https://i.imgur.com/70cXbUI.jpeg",
    LOM: "https://i.imgur.com/HddyTrv.jpeg",
    USDC: "https://i.imgur.com/9UDXcUF.jpeg",
    AXCNH: "https://i.imgur.com/x8317um.jpeg",
    USDT0: "https://i.imgur.com/KgnTsn1.jpeg",
    CNHT0: "https://i.imgur.com/zObg9RY.jpeg"
  },
  CHAIN_ID: 1030,
  TOTAL_REWARD_POOL: 25555555
};

// ==================== åº”ç”¨çŠ¶æ€ ====================
let provider, signer, account;
let router, pair, lom, usdc, axcnh, usdt0, cnht0, axcnhUsdt0Pair, lpRewardContract;
let slippage = 0.1;
let isChinese = true;
let currentRatio = 0;
let fromToken = "CFX";
let toToken = "LOM";
let refreshInterval;
let currentTokenSelector = null;
let transactionLock = false;
let currentReserves = { cfx: 0, lom: 0 };
let lastInputWasFrom = true;
let inviteAddress = '';
let walletInviteMap = JSON.parse(localStorage.getItem('lomswap_wallet_invite_map') || '{}');

// ==================== æ ¸å¿ƒä»£å¸åˆ—è¡¨ ====================
const TOKEN_LIST = [
  {
    symbol: "CFX",
    name: "Conflux",
    address: APP_CONFIG.CONTRACTS.WCFX,
    logo: APP_CONFIG.TOKEN_LOGOS.CFX,
    decimals: 18,
    isNative: true
  },
  {
    symbol: "LOM",
    name: "Longmai",
    address: APP_CONFIG.CONTRACTS.LOM,
    logo: APP_CONFIG.TOKEN_LOGOS.LOM,
    decimals: 18
  },
  {
    symbol: "USDC",
    name: "USD Coin",
    address: APP_CONFIG.CONTRACTS.USDC,
    logo: APP_CONFIG.TOKEN_LOGOS.USDC,
    decimals: 18
  },
  {
    symbol: "AXCNH",
    name: "AxCNH",
    address: APP_CONFIG.CONTRACTS.AXCNH,
    logo: APP_CONFIG.TOKEN_LOGOS.AXCNH,
    decimals: 6
  },
  {
    symbol: "USDT0",
    name: "Tether USD (Test)",
    address: APP_CONFIG.CONTRACTS.USDT0,
    logo: APP_CONFIG.TOKEN_LOGOS.USDT0,
    decimals: 6
  },
  {
    symbol: "CNHT0",
    name: "CNH Token (Test)",
    address: APP_CONFIG.CONTRACTS.CNHT0,
    logo: APP_CONFIG.TOKEN_LOGOS.CNHT0,
    decimals: 6
  }
];

// ==================== åˆçº¦ABIå®šä¹‰ ====================
const ROUTER_ABI = [
  "function getAmountsOut(uint amountIn, address[] path) view returns (uint[] memory amounts)",
  "function swapExactETHForTokensSupportingFeeOnTransferTokens(uint amountOutMin, address[] calldata path, address to, uint deadline) payable",
  "function swapExactTokensForETHSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)",
  "function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)",
  "function addLiquidityETH(address token, uint amountTokenDesired, uint amountTokenMin, uint amountETHMin, address to, uint deadline) payable returns (uint amountToken, uint amountETH, uint liquidity)",
  "function removeLiquidityETHSupportingFeeOnTransferTokens(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) returns (uint amountETH)",
  "function removeLiquidityETH(address token, uint liquidity, uint amountTokenMin, uint amountETHMin, address to, uint deadline) returns (uint amountToken, uint amountETH)"
];

const ERC20_ABI = [
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function balanceOf(address owner) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function totalSupply() view returns (uint256)"
];

const PAIR_ABI = [
  "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address owner) view returns (uint256)",
  "function token0() view returns (address)",
  "function token1() view returns (address)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)"
];

const LP_REWARD_ABI = [
  "function activate(address referrer)",
  "function claimAll()",
  "function claimReferral()",
  "function pendingReward(address user) view returns (uint256)",
  "function pendingReferral(address user) view returns (uint256)",
  "function users(address) view returns (uint256 shares, uint256 rewardDebt, uint256 pendingReferral, uint256 lastClaimTime, uint256 activeTime, uint256 lastReduceTime, uint256 referralUnlockTime, address referrer, bool cleanInFirst30Days)",
  "function minActivation() view returns (uint256)",
  "function totalShares() view returns (uint256)",
  "function rewardPerSecond() view returns (uint256)",
  "function paused() view returns (bool)",
  "function lpToken() view returns (address)",
  "function rewardToken() view returns (address)",
  "function getReferralUnlockTime(address user) view returns (uint256)",
  "function updateShares()",
  "function updateSharesForUser(address userAddr)",
  "function depositReward(uint256 amount)",
  "function depositRewardAsAdmin(uint256 amount)",
  "function setPaused(bool _paused)",
  "function setMinActivation(uint256 amount)",
  "function setBlacklist(address user, bool status)",
  "function transferAdmin(address newAdmin)",
  "function setRewardPerSecond(uint256 rps)",
  "function accRewardPerShare() view returns (uint256)",
  "function lastRewardTime() view returns (uint256)",
  "function emergencyWithdraw(address token, uint256 amount)"
];

// ==================== å·¥å…·æ¨¡å— ====================
const Utils = {
  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  },

  simpleFormat(value) {
    if (!value && value !== 0) return '0.000000';
    const num = parseFloat(value);
    if (isNaN(num)) return '0.000000';
    const truncated = Math.floor(num * 1000000) / 1000000;
    const parts = truncated.toString().split('.');
    let integerPart = parts[0];
    let decimalPart = parts[1] || '';
    if (decimalPart.length < 6) {
      decimalPart = decimalPart.padEnd(6, '0');
    } else if (decimalPart.length > 6) {
      decimalPart = decimalPart.substring(0, 6);
    }
    return integerPart + '.' + decimalPart;
  },

  removeTrailingZeros(str) {
    if (!str.includes('.')) return str;
    let result = str.replace(/0+$/, '');
    if (result.endsWith('.')) {
      result = result.slice(0, -1);
    }
    return result;
  },

  formatDisplay(value) {
    const formatted = this.simpleFormat(value);
    return this.removeTrailingZeros(formatted);
  },

  formatNumber(value) {
    if (!value) return '0';
    const num = parseFloat(value);
    if (isNaN(num)) return '0';
    
    if (num >= 1000000) {
      return (num / 1000000).toFixed(2) + 'M';
    } else if (num >= 1000) {
      return (num / 1000).toFixed(2) + 'K';
    } else if (num >= 1) {
      return num.toFixed(2);
    } else {
      return num.toFixed(6);
    }
  },

  formatAddress(address) {
    if (!address) return '';
    return address.slice(0, 6) + '...' + address.slice(-4);
  },

  isValidAddress(address) {
    return /^0x[a-fA-F0-9]{40}$/.test(address);
  },

  showError(message) {
    const errorBox = document.getElementById('swapErrorBox');
    const errorText = document.getElementById('swapErrorText');
    if (errorBox && errorText) {
      errorText.textContent = message;
      errorBox.classList.add('show');
      setTimeout(() => {
        errorBox.classList.remove('show');
      }, 5000);
    }
  },

  showNotification(message, type = 'info') {
    const status = document.getElementById('txStatusOverlay');
    const icon = document.getElementById('txStatusIcon');
    const title = document.getElementById('txStatusTitle');
    const msg = document.getElementById('txStatusMessage');
    const doneBtn = document.getElementById('txStatusDoneBtn');
    
    if (!status || !icon || !title || !msg) return;
    
    const statusConfig = {
      info: { 
        icon: '<div class="loading-spinner white"></div>', 
        title: isChinese ? 'å¤„ç†ä¸­' : 'Processing' 
      },
      success: { 
        icon: 'âœ…', 
        title: isChinese ? 'æ“ä½œæˆåŠŸ' : 'Success' 
      },
      error: { 
        icon: 'âŒ', 
        title: isChinese ? 'æ“ä½œå¤±è´¥' : 'Failed' 
      }
    };
    
    const config = statusConfig[type] || statusConfig.info;
    icon.innerHTML = config.icon;
    title.textContent = config.title;
    msg.textContent = message;
    
    if (type === 'success' || type === 'error') {
      if (doneBtn) doneBtn.style.display = 'block';
    } else {
      if (doneBtn) doneBtn.style.display = 'none';
    }
    
    status.style.display = 'flex';
  },

  hideNotification() {
    const status = document.getElementById('txStatusOverlay');
    if (status) status.style.display = 'none';
    document.querySelectorAll('button').forEach(btn => {
      btn.disabled = false;
    });
  },

  getErrorMessage(error) {
    const message = error.message || error.toString();
    const errorMap = {
      'user rejected': isChinese ? 'ç”¨æˆ·å–æ¶ˆäº†äº¤æ˜“' : 'Transaction rejected by user',
      'INSUFFICIENT_OUTPUT_AMOUNT': isChinese ? 'è¾“å‡ºæ•°é‡ä¸è¶³ï¼Œè¯·æé«˜æ»‘ç‚¹å®¹å·®' : 'Insufficient output amount, increase slippage',
      'INSUFFICIENT_INPUT_AMOUNT': isChinese ? 'è¾“å…¥æ•°é‡ä¸è¶³' : 'Insufficient input amount',
      'insufficient funds': isChinese ? 'ä½™é¢ä¸è¶³' : 'Insufficient balance',
      'allowance': isChinese ? 'è¯·å…ˆæˆæƒä»£å¸' : 'Please approve token first',
      'deadline': isChinese ? 'äº¤æ˜“è¶…æ—¶ï¼Œè¯·é‡è¯•' : 'Transaction expired, please try again',
      'Not enough liquidity': isChinese ? 'æµåŠ¨æ€§ä¸è¶³' : 'Insufficient liquidity',
      'execution reverted': isChinese ? 'äº¤æ˜“æ‰§è¡Œå¤±è´¥' : 'Transaction execution failed',
      'reverted': isChinese ? 'äº¤æ˜“å¤±è´¥' : 'Transaction failed',
      'Already activated': isChinese ? 'å·²ç»æ¿€æ´»è¿‡äº†' : 'Already activated',
      'Below minimum': isChinese ? 'LPä½™é¢ä¸è¶³æœ€å°æ¿€æ´»è¦æ±‚' : 'LP balance below minimum activation',
      'Too soon': isChinese ? 'é¢†å–é—´éš”å¤ªçŸ­ï¼Œè¯·ç­‰å¾…7å¤©' : 'Claim interval too short, wait 7 days',
      'Cooldown': isChinese ? 'å‡æŒå†·å´ä¸­ï¼Œè¯·ç­‰å¾…24å°æ—¶' : 'Reduce cooldown, wait 24 hours',
      'Blacklisted': isChinese ? 'è´¦æˆ·å·²è¢«åˆ—å…¥é»‘åå•' : 'Account blacklisted'
    };
    
    for (const [key, value] of Object.entries(errorMap)) {
      if (message.toLowerCase().includes(key.toLowerCase())) {
        return value;
      }
    }
    return isChinese ? 'äº¤æ˜“å¤±è´¥ï¼Œè¯·é‡è¯•' : 'Transaction failed, please try again';
  },

  formatTime(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
  },

  formatTimestamp(timestamp) {
    if (!timestamp || timestamp === 0) return '--';
    const date = new Date(timestamp * 1000);
    return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  }
};

// ==================== ä»£å¸å·¥å…·æ¨¡å— ====================
const TokenUtils = {
  getToken(symbol) {
    return TOKEN_LIST.find(t => t.symbol === symbol);
  },

  getTokenDecimals(symbol) {
    const token = this.getToken(symbol);
    return token ? token.decimals : 18;
  },

  getTokenContract(symbol) {
    const tokenContracts = {
      "LOM": lom,
      "USDC": usdc,
      "AXCNH": axcnh,
      "USDT0": usdt0,
      "CNHT0": cnht0
    };
    return tokenContracts[symbol] || null;
  },

  formatTokenAmount(amount, symbol) {
    const decimals = this.getTokenDecimals(symbol);
    try {
      const formatted = ethers.utils.formatUnits(amount, decimals);
      return Utils.formatDisplay(formatted);
    } catch {
      return '0.000000';
    }
  },

  parseTokenAmount(amount, symbol) {
    const decimals = this.getTokenDecimals(symbol);
    try {
      return ethers.utils.parseUnits(amount.toString(), decimals);
    } catch {
      return ethers.BigNumber.from(0);
    }
  }
};

// ==================== LPå¥–åŠ±ç®¡ç†å™¨ ====================
const LPRewardManager = {
  // çŠ¶æ€å®šä¹‰
  REWARD_STATES: {
    NOT_ACTIVATED: 'not_activated',
    ACTIVATED: 'activated',
    NO_LP: 'no_lp',
    PAUSED: 'paused'
  },

  currentState: null,
  userInfo: null,
  contractInfo: null,
  currentLPBalance: 0,
  currentRewards: {
    pendingReward: 0,
    pendingReferral: 0,
    multiplier: 1.0
  },

  refreshTimer: null,
  isSyncing: false,

  // åŒæ­¥åˆçº¦ä»½é¢ï¼ˆå…³é”®ä¿®å¤ï¼‰
  async syncContractShares() {
    if (!account || !lpRewardContract || this.isSyncing) return;
    
    this.isSyncing = true;
    console.log('å¼€å§‹åŒæ­¥åˆçº¦ä»½é¢...');
    
    try {
      // ç­‰å¾…åŒºå—ç¡®è®¤
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // å°è¯•è°ƒç”¨åˆçº¦çš„updateSharesæ–¹æ³•ï¼ˆè¯»å–æ¨¡å¼ï¼‰
      try {
        await lpRewardContract.updateShares();
      } catch (e) {
        console.log('updateShares è°ƒç”¨ï¼ˆåªè¯»æ¨¡å¼ï¼‰:', e.message);
      }
      
      // å°è¯•ä¸ºå½“å‰ç”¨æˆ·æ›´æ–°ä»½é¢
      try {
        await lpRewardContract.updateSharesForUser(account);
      } catch (e) {
        console.log('updateSharesForUser è°ƒç”¨:', e.message);
      }
      
      console.log('åˆçº¦ä»½é¢åŒæ­¥å®Œæˆ');
    } catch (error) {
      console.warn('åŒæ­¥åˆçº¦ä»½é¢å¤±è´¥:', error);
    } finally {
      this.isSyncing = false;
    }
  },

  // åˆ·æ–°æ‰€æœ‰LPå¥–åŠ±ä¿¡æ¯
  async refreshAll() {
    if (!account || !lpRewardContract) {
      this.resetUI();
      return;
    }

    try {
      await this.fetchContractInfo();
      await this.fetchUserInfo();
      await this.fetchLPBalance();
      await this.fetchPendingRewards();
      this.determineCurrentState();
      this.updateUI();
    } catch (error) {
      console.error('åˆ·æ–°LPå¥–åŠ±ä¿¡æ¯å¤±è´¥:', error);
      this.resetUI();
    }
  },

  // è·å–åˆçº¦ä¿¡æ¯
  async fetchContractInfo() {
    try {
      const [
        minActivation,
        totalShares,
        rewardPerSecond,
        pausedStatus,
        rewardTokenAddr,
        lpTokenAddr,
        accRewardPerShare,
        lastRewardTime
      ] = await Promise.all([
        lpRewardContract.minActivation(),
        lpRewardContract.totalShares(),
        lpRewardContract.rewardPerSecond(),
        lpRewardContract.paused(),
        lpRewardContract.rewardToken(),
        lpRewardContract.lpToken(),
        lpRewardContract.accRewardPerShare(),
        lpRewardContract.lastRewardTime()
      ]);

      this.contractInfo = {
        minActivation: parseFloat(ethers.utils.formatUnits(minActivation, 18)),
        totalShares: parseFloat(ethers.utils.formatUnits(totalShares, 18)),
        rewardPerSecond: parseFloat(ethers.utils.formatUnits(rewardPerSecond, 18)),
        paused: pausedStatus,
        rewardTokenAddress: rewardTokenAddr,
        lpTokenAddress: lpTokenAddr,
        accRewardPerShare: parseFloat(ethers.utils.formatUnits(accRewardPerShare, 12)),
        lastRewardTime: lastRewardTime.toNumber()
      };
      
      console.log('åˆçº¦æ€»ä»½é¢:', this.contractInfo.totalShares);
    } catch (error) {
      console.error('è·å–åˆçº¦ä¿¡æ¯å¤±è´¥:', error);
      throw error;
    }
  },

  // è·å–ç”¨æˆ·ä¿¡æ¯
  async fetchUserInfo() {
    try {
      const userData = await lpRewardContract.users(account);

      this.userInfo = {
        shares: parseFloat(ethers.utils.formatUnits(userData.shares, 18)),
        rewardDebt: parseFloat(ethers.utils.formatUnits(userData.rewardDebt, 12)),
        pendingReferral: parseFloat(ethers.utils.formatUnits(userData.pendingReferral, 18)),
        lastClaimTime: userData.lastClaimTime.toNumber(),
        activeTime: userData.activeTime.toNumber(),
        lastReduceTime: userData.lastReduceTime.toNumber(),
        referralUnlockTime: userData.referralUnlockTime.toNumber(),
        referrer: userData.referrer,
        cleanInFirst30Days: userData.cleanInFirst30Days
      };
      
      console.log('ç”¨æˆ·ä»½é¢:', this.userInfo.shares);
    } catch (error) {
      console.error('è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥:', error);
      this.userInfo = {
        shares: 0,
        rewardDebt: 0,
        pendingReferral: 0,
        lastClaimTime: 0,
        activeTime: 0,
        lastReduceTime: 0,
        referralUnlockTime: 0,
        referrer: '0x0000000000000000000000000000000000000000',
        cleanInFirst30Days: false
      };
    }
  },

  // è·å–LPä½™é¢
  async fetchLPBalance() {
    try {
      if (pair) {
        const lpBal = await pair.balanceOf(account);
        this.currentLPBalance = parseFloat(ethers.utils.formatUnits(lpBal, 18));
      }
    } catch (error) {
      console.error('è·å–LPä½™é¢å¤±è´¥:', error);
      this.currentLPBalance = 0;
    }
  },

  // è·å–å¾…é¢†å–å¥–åŠ±
  async fetchPendingRewards() {
    try {
      const pendingReward = await lpRewardContract.pendingReward(account);
      this.currentRewards.pendingReward = parseFloat(ethers.utils.formatUnits(pendingReward, 18));

      const pendingReferral = await lpRewardContract.pendingReferral(account);
      this.currentRewards.pendingReferral = parseFloat(ethers.utils.formatUnits(pendingReferral, 18));

      // è®¡ç®—å€ç‡
      this.currentRewards.multiplier = this.calculateMultiplier();
    } catch (error) {
      console.error('è·å–å¥–åŠ±æ•°æ®å¤±è´¥:', error);
      this.currentRewards = {
        pendingReward: 0,
        pendingReferral: 0,
        multiplier: 1.0
      };
    }
  },

  // è®¡ç®—å€ç‡
  calculateMultiplier() {
    if (!this.userInfo || this.userInfo.activeTime === 0) return 1.0;

    const now = Math.floor(Date.now() / 1000);
    const duration = now - this.userInfo.activeTime;

    if (this.contractInfo.paused) return 1.0;
    
    if (duration >= 360 * 24 * 60 * 60) return 3.0;
    if (duration >= 180 * 24 * 60 * 60) return 2.0;
    if (duration >= 90 * 24 * 60 * 60) return 1.5;
    if (duration >= 30 * 24 * 60 * 60) return 1.0;
    return 0.8;
  },

  // ç¡®å®šå½“å‰çŠ¶æ€
  determineCurrentState() {
    if (this.contractInfo.paused) {
      this.currentState = this.REWARD_STATES.PAUSED;
      return;
    }

    if (!this.userInfo || this.userInfo.shares <= 0) {
      this.currentState = this.REWARD_STATES.NOT_ACTIVATED;
      return;
    }

    if (this.currentLPBalance >= this.contractInfo.minActivation) {
      this.currentState = this.REWARD_STATES.ACTIVATED;
    } else {
      this.currentState = this.REWARD_STATES.NO_LP;
    }
  },

  // æ›´æ–°UI
  updateUI() {
    this.updateActivationStatus();
    this.updateRewardInfo();
    this.updateMultiplierDisplay();
    this.updateReferralSystem();
    this.updateButtonStates();
    this.updateWarnings();
    this.updateGlobalStats();
  },

  // æ›´æ–°æ¿€æ´»çŠ¶æ€æ˜¾ç¤º
  updateActivationStatus() {
    const activationStatus = document.getElementById('activationStatus');
    if (!activationStatus) return;

    switch (this.currentState) {
      case this.REWARD_STATES.NOT_ACTIVATED:
        activationStatus.textContent = 'æœªæ¿€æ´»';
        activationStatus.className = 'lp-reward-card-value warning';
        break;
      case this.REWARD_STATES.ACTIVATED:
        activationStatus.textContent = 'å·²æ¿€æ´»';
        activationStatus.className = 'lp-reward-card-value success';
        break;
      case this.REWARD_STATES.NO_LP:
        activationStatus.textContent = 'LPä¸è¶³';
        activationStatus.className = 'lp-reward-card-value warning';
        break;
      case this.REWARD_STATES.PAUSED:
        activationStatus.textContent = 'å·²æš‚åœ';
        activationStatus.className = 'lp-reward-card-value warning';
        break;
    }

    const lpBalanceEl = document.getElementById('lpBalance');
    if (lpBalanceEl) {
      lpBalanceEl.textContent = `${Utils.formatDisplay(this.currentLPBalance)} LPT`;
    }

    const daysHeldEl = document.getElementById('daysHeld');
    if (daysHeldEl) {
      if (this.userInfo && this.userInfo.activeTime > 0) {
        const daysHeld = Math.floor((Date.now() / 1000 - this.userInfo.activeTime) / 86400);
        daysHeldEl.textContent = `${daysHeld} å¤©`;
      } else {
        daysHeldEl.textContent = '0 å¤©';
      }
    }
  },

  // æ›´æ–°å¥–åŠ±ä¿¡æ¯
  updateRewardInfo() {
    const pendingRewardEl = document.getElementById('pendingReward');
    if (pendingRewardEl) {
      pendingRewardEl.textContent = `${Utils.formatDisplay(this.currentRewards.pendingReward)} LOM`;
    }

    const dailyRewardEl = document.getElementById('dailyReward');
    if (dailyRewardEl) {
      if (this.currentState === this.REWARD_STATES.ACTIVATED && 
          this.userInfo && this.userInfo.shares > 0 && 
          this.contractInfo.totalShares > 0) {
        
        const dailyReward = this.contractInfo.rewardPerSecond * 
                          this.userInfo.shares / this.contractInfo.totalShares * 
                          86400 * this.currentRewards.multiplier;
        dailyRewardEl.textContent = `${Utils.formatDisplay(dailyReward)} LOM`;
      } else {
        dailyRewardEl.textContent = '0 LOM';
      }
    }

    const nextClaimTimeEl = document.getElementById('nextClaimTime');
    if (nextClaimTimeEl) {
      if (this.userInfo && this.userInfo.lastClaimTime > 0) {
        const nextClaimTime = this.userInfo.lastClaimTime + 7 * 24 * 60 * 60;
        const now = Math.floor(Date.now() / 1000);

        if (now >= nextClaimTime) {
          nextClaimTimeEl.textContent = 'ç°åœ¨å¯ä»¥é¢†å–';
        } else {
          const timeLeft = nextClaimTime - now;
          const daysLeft = Math.floor(timeLeft / 86400);
          const hoursLeft = Math.floor((timeLeft % 86400) / 3600);
          nextClaimTimeEl.textContent = `${daysLeft}å¤©${hoursLeft}å°æ—¶å`;
        }
      } else {
        nextClaimTimeEl.textContent = '--';
      }
    }

    const pendingReferralEl = document.getElementById('pendingReferral');
    if (pendingReferralEl) {
      pendingReferralEl.textContent = `${Utils.formatDisplay(this.currentRewards.pendingReferral)} LOM`;
    }
  },

  // æ›´æ–°å€ç‡æ˜¾ç¤º
  updateMultiplierDisplay() {
    const multiplierEl = document.getElementById('rewardMultiplier');
    if (multiplierEl) {
      multiplierEl.textContent = `${this.currentRewards.multiplier.toFixed(1)}x`;
      multiplierEl.className = 'lp-reward-card-value success';
    }

    this.updateMultiplierHighlight();
  },

  // æ›´æ–°å€ç‡é«˜äº®
  updateMultiplierHighlight() {
    document.querySelectorAll('.lp-reward-multiplier-item').forEach(item => {
      item.classList.remove('active');
    });

    const multiplier = this.currentRewards.multiplier;
    if (multiplier >= 3.0) {
      document.getElementById('multiplier360d')?.classList.add('active');
    } else if (multiplier >= 2.0) {
      document.getElementById('multiplier180d')?.classList.add('active');
    } else if (multiplier >= 1.5) {
      document.getElementById('multiplier90d')?.classList.add('active');
    } else if (multiplier >= 1.0) {
      document.getElementById('multiplier30d')?.classList.add('active');
    } else {
      document.getElementById('multiplier30d')?.classList.add('active');
    }
  },

  // æ›´æ–°æ¨èç³»ç»Ÿ
  updateReferralSystem() {
    const referralSection = document.getElementById('referralSection');
    const referralStatsContainer = document.getElementById('referralStatsContainer');

    if (!referralSection || !referralStatsContainer) return;

    if (this.currentState === this.REWARD_STATES.NOT_ACTIVATED) {
      referralSection.style.display = 'block';
      referralStatsContainer.innerHTML = '';

      const referrerInput = document.getElementById('referrerAddress');
      if (referrerInput) {
        referrerInput.disabled = false;
        referrerInput.placeholder = 'è¾“å…¥æ¨èäººåœ°å€ (å¯é€‰)';
        referrerInput.value = walletInviteMap[account.toLowerCase()] || '';
      }
    } else {
      referralSection.style.display = 'none';
      this.showReferralStats();
    }
  },

  // æ˜¾ç¤ºæ¨èç»Ÿè®¡
  showReferralStats() {
    const container = document.getElementById('referralStatsContainer');
    if (!container) return;

    let statsHTML = '';

    if (this.userInfo.referrer && this.userInfo.referrer !== '0x0000000000000000000000000000000000000000') {
      statsHTML = `
        <div class="referral-stats-panel">
          <div class="referral-stat-row">
            <div class="referral-stat-label">æ¨èäºº</div>
            <div class="referral-stat-value">${Utils.formatAddress(this.userInfo.referrer)}</div>
          </div>
          <div class="referral-stat-row">
            <div class="referral-stat-label">å¾…é¢†å–æ¨èå¥–åŠ±</div>
            <div class="referral-stat-value">${Utils.formatDisplay(this.currentRewards.pendingReferral)} LOM</div>
          </div>
          <div class="referral-stat-row">
            <div class="referral-stat-label">æ¨èå¥–åŠ±è§£é”æ—¶é—´</div>
            <div class="referral-stat-value">${Utils.formatTimestamp(this.userInfo.referralUnlockTime)}</div>
          </div>
          <div class="referral-stat-row">
            <div class="referral-stat-label">30å¤©æŒä»“çŠ¶æ€</div>
            <div class="referral-stat-value">${this.userInfo.cleanInFirst30Days ? 'âœ… ä¿æŒä¸­' : 'âŒ å·²å¤±æ•ˆ'}</div>
          </div>
        </div>
      `;
    } else {
      statsHTML = `
        <div class="referral-stats-panel">
          <div class="referral-stat-row">
            <div class="referral-stat-label">æ¨èçŠ¶æ€</div>
            <div class="referral-stat-value">æ— æ¨èäºº</div>
          </div>
        </div>
      `;
    }

    container.innerHTML = statsHTML;
  },

  // æ›´æ–°æŒ‰é’®çŠ¶æ€
  updateButtonStates() {
    const activateBtn = document.getElementById('activateBtn');
    const claimBtn = document.getElementById('claimBtn');
    const claimReferralBtn = document.getElementById('claimReferralBtn');

    if (!activateBtn || !claimBtn || !claimReferralBtn) return;

    switch (this.currentState) {
      case this.REWARD_STATES.NOT_ACTIVATED:
        activateBtn.disabled = !this.canActivate() || this.contractInfo.paused;
        activateBtn.innerHTML = this.contractInfo.paused ? 
          '<span>â¸ï¸</span><span>åˆçº¦æš‚åœ</span>' : 
          (this.canActivate() ? 
            '<span>ğŸš€</span><span>æ¿€æ´»å¥–åŠ±</span>' : 
            '<span>â³</span><span>LPä¸è¶³</span>');

        claimBtn.disabled = true;
        claimBtn.innerHTML = '<span>ğŸ’°</span><span>é¢†å–å¥–åŠ±</span>';

        claimReferralBtn.disabled = true;
        claimReferralBtn.innerHTML = '<span>ğŸ</span><span>é¢†å–æ¨è</span>';
        break;

      case this.REWARD_STATES.ACTIVATED:
        activateBtn.disabled = true;
        activateBtn.innerHTML = '<span>âœ…</span><span>å·²æ¿€æ´»</span>';

        const now = Math.floor(Date.now() / 1000);
        const nextClaimTime = this.userInfo.lastClaimTime + 7 * 24 * 60 * 60;
        claimBtn.disabled = now < nextClaimTime || 
                          this.currentRewards.pendingReward <= 0 || 
                          this.contractInfo.paused;
        claimBtn.innerHTML = '<span>ğŸ’°</span><span>é¢†å–å¥–åŠ±</span>';

        const canClaimReferral = this.currentRewards.pendingReferral > 0 && 
                               now >= this.userInfo.referralUnlockTime;
        claimReferralBtn.disabled = !canClaimReferral || this.contractInfo.paused;
        claimReferralBtn.innerHTML = '<span>ğŸ</span><span>é¢†å–æ¨è</span>';
        break;

      case this.REWARD_STATES.NO_LP:
        activateBtn.disabled = true;
        activateBtn.innerHTML = '<span>â¸ï¸</span><span>LPä¸è¶³</span>';

        claimBtn.disabled = this.currentRewards.pendingReward <= 0 || this.contractInfo.paused;
        claimBtn.innerHTML = '<span>ğŸ’°</span><span>é¢†å–å¥–åŠ±</span>';

        claimReferralBtn.disabled = this.currentRewards.pendingReferral <= 0 || this.contractInfo.paused;
        claimReferralBtn.innerHTML = '<span>ğŸ</span><span>é¢†å–æ¨è</span>';
        break;

      case this.REWARD_STATES.PAUSED:
        activateBtn.disabled = true;
        activateBtn.innerHTML = '<span>â¸ï¸</span><span>åˆçº¦æš‚åœ</span>';

        claimBtn.disabled = true;
        claimBtn.innerHTML = '<span>ğŸ’°</span><span>é¢†å–å¥–åŠ±</span>';

        claimReferralBtn.disabled = true;
        claimReferralBtn.innerHTML = '<span>ğŸ</span><span>é¢†å–æ¨è</span>';
        break;
    }
  },

  // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ¿€æ´»
  canActivate() {
    return this.currentLPBalance >= this.contractInfo.minActivation;
  },

  // æ›´æ–°è­¦å‘Šä¿¡æ¯
  updateWarnings() {
    const warningElement = document.getElementById('lpWarning');
    const cooldownTimer = document.getElementById('cooldownTimer');

    if (!warningElement || !cooldownTimer) return;

    warningElement.style.display = 'none';
    cooldownTimer.style.display = 'none';

    switch (this.currentState) {
      case this.REWARD_STATES.NO_LP:
        warningElement.style.display = 'block';
        warningElement.innerHTML = `
          <div class="lp-reward-warning-icon">âš ï¸</div>
          <div class="lp-reward-warning-text">
            LPä»£å¸ä½™é¢ä¸è¶³ï¼Œå¥–åŠ±å·²åœæ­¢ç´¯ç§¯ã€‚
            <br><small>è¯·æ·»åŠ æµåŠ¨æ€§ä»¥ç»§ç»­è·å–å¥–åŠ±ã€‚æ‚¨çš„æ¿€æ´»çŠ¶æ€ä»ç„¶æœ‰æ•ˆã€‚</small>
          </div>
        `;
        break;

      case this.REWARD_STATES.PAUSED:
        warningElement.style.display = 'block';
        warningElement.innerHTML = `
          <div class="lp-reward-warning-icon">â¸ï¸</div>
          <div class="lp-reward-warning-text">
            å¥–åŠ±åˆçº¦å·²æš‚åœï¼Œæ‰€æœ‰æ“ä½œæš‚æ—¶ä¸å¯ç”¨ã€‚
          </div>
        `;
        break;
    }

    // æ£€æŸ¥å†·å´æ—¶é—´
    if (this.userInfo && this.userInfo.lastReduceTime > 0) {
      const cooldownPeriod = 24 * 60 * 60;
      const now = Math.floor(Date.now() / 1000);
      const timeLeft = this.userInfo.lastReduceTime + cooldownPeriod - now;

      if (timeLeft > 0) {
        cooldownTimer.style.display = 'block';
        document.getElementById('cooldownTime').textContent = Utils.formatTime(timeLeft);
      }
    }
  },

  // æ›´æ–°å…¨å±€ç»Ÿè®¡
  updateGlobalStats() {
    const container = document.getElementById('globalStatsContainer');
    if (!container) return;

    // ä¼°ç®—æ€»å¥–åŠ±å‘æ”¾é‡
    const totalSeconds = Date.now() / 1000 - this.contractInfo.lastRewardTime;
    const estimatedDistributed = this.contractInfo.rewardPerSecond * totalSeconds;
    const rewardPercentage = (estimatedDistributed / APP_CONFIG.TOTAL_REWARD_POOL * 100).toFixed(2);
    const remainingReward = Math.max(0, APP_CONFIG.TOTAL_REWARD_POOL - estimatedDistributed);

    const statsHTML = `
      <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(138, 43, 226, 0.05)); border-radius: 12px; padding: 16px; border: 1px solid rgba(255, 215, 0, 0.3); margin-bottom: 20px;">
        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px; text-align: center;">
          ğŸ“Š å…¨å±€ç»Ÿè®¡ ${this.contractInfo.paused ? '<span style="color: var(--accent-red);">(æš‚åœ)</span>' : ''}
        </div>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; font-size: 11px;">
          <div style="text-align: center;">
            <div style="color: var(--text-secondary);">æ€»è´¨æŠ¼</div>
            <div style="color: var(--accent-yellow); font-weight: 600;">${Utils.formatNumber(this.contractInfo.totalShares)} LPT</div>
          </div>
          <div style="text-align: center;">
            <div style="color: var(--text-secondary);">æ¯ç§’å¥–åŠ±</div>
            <div style="color: var(--primary-blue); font-weight: 600;">${Utils.formatDisplay(this.contractInfo.rewardPerSecond)} LOM</div>
          </div>
          <div style="text-align: center;">
            <div style="color: var(--text-secondary);">æ€»å¥–æ± </div>
            <div style="color: var(--success); font-weight: 600;">${Utils.formatNumber(APP_CONFIG.TOTAL_REWARD_POOL)} LOM</div>
          </div>
          <div style="text-align: center;">
            <div style="color: var(--text-secondary);">æœ€å°æ¿€æ´»</div>
            <div style="color: var(--text-primary); font-weight: 600;">${Utils.formatNumber(this.contractInfo.minActivation)} LPT</div>
          </div>
        </div>
        
        <!-- è¿›åº¦æ¡ -->
        <div style="margin-top: 12px;">
          <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
            <span style="font-size: 10px; color: var(--text-secondary);">å‘æ”¾è¿›åº¦</span>
            <span style="font-size: 10px; color: var(--text-secondary);">å‰©ä½™: ${Utils.formatNumber(remainingReward)} LOM</span>
          </div>
          <div style="height: 6px; background: rgba(255, 255, 255, 0.1); border-radius: 3px; overflow: hidden;">
            <div style="height: 100%; width: ${Math.min(rewardPercentage, 100)}%; background: linear-gradient(90deg, var(--success), var(--accent-yellow)); border-radius: 3px; transition: width 0.3s ease;"></div>
          </div>
          <div style="display: flex; justify-content: space-between; margin-top: 4px;">
            <span style="font-size: 10px; color: var(--text-secondary);">å·²å‘: ${Utils.formatNumber(estimatedDistributed)} LOM</span>
            <span style="font-size: 10px; color: var(--text-secondary);">æ€»æ± : ${Utils.formatNumber(APP_CONFIG.TOTAL_REWARD_POOL)} LOM</span>
          </div>
        </div>
        
        <!-- åˆçº¦çŠ¶æ€ -->
        <div style="margin-top: 12px; padding: 8px; background: ${this.contractInfo.paused ? 'rgba(255, 71, 87, 0.1)' : 'rgba(46, 160, 67, 0.1)'}; border-radius: 8px; text-align: center;">
          <div style="font-size: 11px; color: ${this.contractInfo.paused ? 'var(--accent-red)' : 'var(--success)'}; font-weight: 600;">
            ${this.contractInfo.paused ? 'â¸ï¸ åˆçº¦å·²æš‚åœ' : 'âœ… åˆçº¦è¿è¡Œä¸­'}
          </div>
        </div>
      </div>
    `;

    container.innerHTML = statsHTML;
  },

  // æ¿€æ´»å¥–åŠ±
  async activate() {
    if (!account || !lpRewardContract) {
      Utils.showError('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (this.currentState !== this.REWARD_STATES.NOT_ACTIVATED) {
      Utils.showError('æ‚¨å·²ç»æ¿€æ´»äº†å¥–åŠ±ç³»ç»Ÿ');
      return;
    }

    if (this.contractInfo.paused) {
      Utils.showError('åˆçº¦å·²æš‚åœï¼Œæ— æ³•æ¿€æ´»');
      return;
    }

    // è·å–æ¨èåœ°å€
    const referrerInput = document.getElementById('referrerAddress');
    let referrerAddress = referrerInput ? referrerInput.value.trim() : '';

    // éªŒè¯æ¨èåœ°å€
    if (referrerAddress && !Utils.isValidAddress(referrerAddress)) {
      Utils.showError('æ¨èåœ°å€æ ¼å¼é”™è¯¯');
      return;
    }

    // å¦‚æœæ¨èåœ°å€ä¸ºç©ºæˆ–æ— æ•ˆï¼Œè®¾ç½®ä¸ºé›¶åœ°å€
    if (!referrerAddress || referrerAddress === account) {
      referrerAddress = '0x0000000000000000000000000000000000000000';
    }

    try {
      Utils.showNotification('æ¿€æ´»LPå¥–åŠ±ä¸­...', 'info');

      const tx = await lpRewardContract.activate(referrerAddress);
      await tx.wait();

      Utils.showNotification('æ¿€æ´»æˆåŠŸï¼7å¤©åå¯ä»¥å¼€å§‹é¢†å–å¥–åŠ±', 'success');

      // ä¿å­˜æ¨èåœ°å€åˆ°æœ¬åœ°å­˜å‚¨
      if (referrerAddress !== '0x0000000000000000000000000000000000000000') {
        walletInviteMap[account.toLowerCase()] = referrerAddress;
        localStorage.setItem('lomswap_wallet_invite_map', JSON.stringify(walletInviteMap));
      }

      // åˆ·æ–°æ‰€æœ‰æ•°æ®
      await this.refreshAll();
      await DataManager.refreshAll();

    } catch (error) {
      console.error('æ¿€æ´»å¤±è´¥:', error);
      Utils.showNotification(Utils.getErrorMessage(error), 'error');
    }
  },

  // é¢†å–å¥–åŠ±
  async claimReward() {
    if (!account || !lpRewardContract) {
      Utils.showError('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (this.contractInfo.paused) {
      Utils.showError('åˆçº¦å·²æš‚åœï¼Œæ— æ³•é¢†å–');
      return;
    }

    if (this.currentRewards.pendingReward <= 0) {
      Utils.showError('æ²¡æœ‰å¯é¢†å–çš„å¥–åŠ±');
      return;
    }

    const now = Math.floor(Date.now() / 1000);
    const nextClaimTime = this.userInfo.lastClaimTime + 7 * 24 * 60 * 60;
    if (now < nextClaimTime) {
      Utils.showError('é¢†å–å†·å´ä¸­ï¼Œè¯·ç­‰å¾…');
      return;
    }

    try {
      Utils.showNotification('é¢†å–å¥–åŠ±ä¸­...', 'info');

      const tx = await lpRewardContract.claimAll();
      await tx.wait();

      Utils.showNotification(`å¥–åŠ±é¢†å–æˆåŠŸï¼è·å¾— ${Utils.formatDisplay(this.currentRewards.pendingReward)} LOM`, 'success');

      // åˆ·æ–°æ•°æ®
      await this.refreshAll();
      await DataManager.refreshAll();

    } catch (error) {
      console.error('é¢†å–å¥–åŠ±å¤±è´¥:', error);
      Utils.showNotification(Utils.getErrorMessage(error), 'error');
    }
  },

  // é¢†å–æ¨èå¥–åŠ±
  async claimReferralReward() {
    if (!account || !lpRewardContract) {
      Utils.showError('è¯·å…ˆè¿æ¥é’±åŒ…');
      return;
    }

    if (this.contractInfo.paused) {
      Utils.showError('åˆçº¦å·²æš‚åœï¼Œæ— æ³•é¢†å–');
      return;
    }

    if (this.currentRewards.pendingReferral <= 0) {
      Utils.showError('æ²¡æœ‰å¯é¢†å–çš„æ¨èå¥–åŠ±');
      return;
    }

    const now = Math.floor(Date.now() / 1000);
    if (now < this.userInfo.referralUnlockTime) {
      Utils.showError('æ¨èå¥–åŠ±è¿˜æœªè§£é”');
      return;
    }

    try {
      Utils.showNotification('é¢†å–æ¨èå¥–åŠ±ä¸­...', 'info');

      const tx = await lpRewardContract.claimReferral();
      await tx.wait();

      Utils.showNotification(`æ¨èå¥–åŠ±é¢†å–æˆåŠŸï¼è·å¾— ${Utils.formatDisplay(this.currentRewards.pendingReferral)} LOM`, 'success');

      // åˆ·æ–°æ•°æ®
      await this.refreshAll();

    } catch (error) {
      console.error('é¢†å–æ¨èå¥–åŠ±å¤±è´¥:', error);
      Utils.showNotification(Utils.getErrorMessage(error), 'error');
    }
  },

  // é‡ç½®UI
  resetUI() {
    this.currentState = null;
    this.userInfo = null;
    this.contractInfo = null;
    this.currentLPBalance = 0;
    this.currentRewards = {
      pendingReward: 0,
      pendingReferral: 0,
      multiplier: 1.0
    };

    const elements = {
      'activationStatus': { text: 'æœªæ¿€æ´»', className: 'lp-reward-card-value warning' },
      'lpBalance': { text: '0 LPT', className: '' },
      'daysHeld': { text: '0 å¤©', className: '' },
      'rewardMultiplier': { text: '1.0x', className: 'lp-reward-card-value success' },
      'pendingReward': { text: '0 LOM', className: '' },
      'dailyReward': { text: '0 LOM', className: '' },
      'nextClaimTime': { text: '--', className: '' },
      'pendingReferral': { text: '0 LOM', className: '' }
    };

    Object.entries(elements).forEach(([id, data]) => {
      const element = document.getElementById(id);
      if (element) {
        element.textContent = data.text;
        if (data.className) element.className = data.className;
      }
    });

    const activateBtn = document.getElementById('activateBtn');
    const claimBtn = document.getElementById('claimBtn');
    const claimReferralBtn = document.getElementById('claimReferralBtn');

    if (activateBtn) {
      activateBtn.disabled = true;
      activateBtn.innerHTML = '<span>ğŸš€</span><span>è¿æ¥é’±åŒ…</span>';
    }
    if (claimBtn) {
      claimBtn.disabled = true;
      claimBtn.innerHTML = '<span>ğŸ’°</span><span>é¢†å–å¥–åŠ±</span>';
    }
    if (claimReferralBtn) {
      claimReferralBtn.disabled = true;
      claimReferralBtn.innerHTML = '<span>ğŸ</span><span>é¢†å–æ¨è</span>';
    }

    const referralSection = document.getElementById('referralSection');
    if (referralSection) {
      referralSection.style.display = 'block';
    }

    const referralStatsContainer = document.getElementById('referralStatsContainer');
    if (referralStatsContainer) {
      referralStatsContainer.innerHTML = '';
    }

    const globalStatsContainer = document.getElementById('globalStatsContainer');
    if (globalStatsContainer) {
      globalStatsContainer.innerHTML = '';
    }

    const warningElement = document.getElementById('lpWarning');
    if (warningElement) warningElement.style.display = 'none';
    
    const cooldownTimer = document.getElementById('cooldownTimer');
    if (cooldownTimer) cooldownTimer.style.display = 'none';

    this.resetMultiplierHighlight();
  },

  // é‡ç½®å€ç‡é«˜äº®
  resetMultiplierHighlight() {
    document.querySelectorAll('.lp-reward-multiplier-item').forEach(item => {
      item.classList.remove('active');
    });
  },

  // å¼€å§‹è‡ªåŠ¨åˆ·æ–°
  startAutoRefresh() {
    if (this.refreshTimer) clearInterval(this.refreshTimer);

    this.refreshTimer = setInterval(() => {
      if (account && document.getElementById('lpRewardTab').classList.contains('active')) {
        this.refreshAll();
      }
    }, 15000);
  },

  // åœæ­¢è‡ªåŠ¨åˆ·æ–°
  stopAutoRefresh() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
      this.refreshTimer = null;
    }
  }
};

// ==================== æ ¸å¿ƒåº”ç”¨æ¨¡å— ====================
class AppCore {
  static async connectWallet() {
    try {
      if (!window.ethereum) {
        Utils.showError(isChinese ? "è¯·å®‰è£…TPæˆ–web3é’±åŒ…" : "Please install TP or WEB3 wallet");
        return false;
      }
      
      const walletBtn = document.getElementById('walletBtn');
      walletBtn.textContent = isChinese ? 'è¿æ¥ä¸­...' : 'Connecting...';
      walletBtn.classList.add('connecting');
      
      const accounts = await window.ethereum.request({
        method: 'eth_requestAccounts'
      });
      
      if (!accounts || accounts.length === 0) {
        throw new Error(isChinese ? 'ç”¨æˆ·æ‹’ç»è¿æ¥' : 'User rejected connection');
      }
      
      account = accounts[0];
      provider = new ethers.providers.Web3Provider(window.ethereum);
      signer = provider.getSigner();
      
      await this.checkNetwork();
      this.initContracts();
      this.restoreInviteAddress();
      this.updateUI();
      
      // å¯åŠ¨æ•°æ®åˆ·æ–°
      if (refreshInterval) clearInterval(refreshInterval);
      refreshInterval = setInterval(() => {
        DataManager.refreshAll();
        if (document.getElementById('lpRewardTab').classList.contains('active')) {
          LPRewardManager.refreshAll();
        }
      }, 10000);
      
      Utils.showNotification(
        isChinese ? 'é’±åŒ…è¿æ¥æˆåŠŸ' : 'Wallet connected successfully',
        'success'
      );
      
      // åˆå§‹åŒ–æ•°æ®
      await DataManager.refreshAll();
      await LPRewardManager.refreshAll();
      LPRewardManager.startAutoRefresh();
      
      return true;
    } catch (error) {
      console.error("é’±åŒ…è¿æ¥å¤±è´¥:", error);
      Utils.showError(
        isChinese ? `è¿æ¥å¤±è´¥: ${error.message}` : `Connection failed: ${error.message}`
      );
      return false;
    } finally {
      this.updateUI();
    }
  }

  static async checkNetwork() {
    const network = await provider.getNetwork();
    if (network.chainId !== APP_CONFIG.CHAIN_ID) {
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x' + APP_CONFIG.CHAIN_ID.toString(16) }]
        });
      } catch (error) {
        if (error.code === 4902) {
          Utils.showError(isChinese ? 'è¯·æ·»åŠ Conflux eSpaceç½‘ç»œ' : 'Please add Conflux eSpace network');
        } else {
          Utils.showError(isChinese ? 'è¯·åˆ‡æ¢åˆ°Conflux eSpaceç½‘ç»œ' : 'Please switch to Conflux eSpace network');
        }
        throw error;
      }
    }
  }

  static initContracts() {
    router = new ethers.Contract(APP_CONFIG.CONTRACTS.ROUTER, ROUTER_ABI, signer);
    pair = new ethers.Contract(APP_CONFIG.CONTRACTS.PAIR, PAIR_ABI, signer);
    lom = new ethers.Contract(APP_CONFIG.CONTRACTS.LOM, ERC20_ABI, signer);
    usdc = new ethers.Contract(APP_CONFIG.CONTRACTS.USDC, ERC20_ABI, signer);
    axcnh = new ethers.Contract(APP_CONFIG.CONTRACTS.AXCNH, ERC20_ABI, signer);
    usdt0 = new ethers.Contract(APP_CONFIG.CONTRACTS.USDT0, ERC20_ABI, signer);
    cnht0 = new ethers.Contract(APP_CONFIG.CONTRACTS.CNHT0, ERC20_ABI, signer);
    axcnhUsdt0Pair = new ethers.Contract(APP_CONFIG.CONTRACTS.AXCNH_USDT0_PAIR, PAIR_ABI, signer);
    
    // åˆå§‹åŒ–LPå¥–åŠ±åˆçº¦
    if (APP_CONFIG.CONTRACTS.LP_REWARD) {
      const contractProvider = signer || provider;
      
      lpRewardContract = new ethers.Contract(
        APP_CONFIG.CONTRACTS.LP_REWARD,
        LP_REWARD_ABI,
        contractProvider
      );
      
      console.log('âœ… LPå¥–åŠ±åˆçº¦åˆå§‹åŒ–æˆåŠŸ');
    }
  }

  static restoreInviteAddress() {
    if (account && walletInviteMap[account.toLowerCase()]) {
      inviteAddress = walletInviteMap[account.toLowerCase()];
      const referrerInput = document.getElementById('referrerAddress');
      if (referrerInput) {
        referrerInput.value = inviteAddress;
      }
    } else {
      inviteAddress = '';
    }
  }

  static updateUI() {
    const walletBtn = document.getElementById("walletBtn");
    const swapBtn = document.getElementById("swapBtn");
    
    if (walletBtn) walletBtn.classList.remove('connecting');
    
    if (account) {
      const displayAddress = Utils.formatAddress(account);
      if (walletBtn) {
        walletBtn.textContent = displayAddress;
        walletBtn.classList.add('connected');
      }
      if (swapBtn) {
        swapBtn.textContent = isChinese ? "è¯·è¾“å…¥æ•°é‡" : "Enter Amount";
        swapBtn.disabled = false;
      }
    } else {
      if (walletBtn) {
        walletBtn.textContent = isChinese ? "è¿æ¥é’±åŒ…" : "Connect Wallet";
        walletBtn.classList.remove('connected');
      }
      if (swapBtn) {
        swapBtn.textContent = isChinese ? "è¿æ¥é’±åŒ…" : "Connect Wallet";
        swapBtn.disabled = false;
      }
    }
  }

  static disconnect() {
    account = null;
    provider = null;
    signer = null;
    router = null;
    pair = null;
    lom = null;
    usdc = null;
    axcnh = null;
    usdt0 = null;
    cnht0 = null;
    axcnhUsdt0Pair = null;
    lpRewardContract = null;
    
    if (refreshInterval) {
      clearInterval(refreshInterval);
      refreshInterval = null;
    }
    
    LPRewardManager.stopAutoRefresh();
    LPRewardManager.resetUI();
    DataManager.resetAllData();
    
    this.updateUI();
    
    Utils.showNotification(
      isChinese ? "é’±åŒ…å·²æ–­å¼€è¿æ¥" : "Wallet disconnected",
      'success'
    );
  }
}

// ==================== æ•°æ®ç®¡ç†å™¨ ====================
const DataManager = {
  async refreshAll() {
    if (!account) return;
    try {
      await this.updateAllBalances();
      await this.updatePoolInfo();
      this.updateSwapButtonState();
    } catch (error) {
      console.error('åˆ·æ–°æ•°æ®å¤±è´¥:', error);
    }
  },

  async updateAllBalances() {
    if (!account) return;
    
    try {
      const balancePromises = TOKEN_LIST.map(async (token) => {
        try {
          let balance = 0;
          
          if (token.symbol === 'CFX' && provider) {
            const cfxBal = await provider.getBalance(account);
            balance = parseFloat(ethers.utils.formatEther(cfxBal));
          } else {
            const contract = TokenUtils.getTokenContract(token.symbol);
            if (contract) {
              const tokenBal = await contract.balanceOf(account);
              balance = parseFloat(ethers.utils.formatUnits(tokenBal, token.decimals));
            }
          }
          
          return { symbol: token.symbol, balance };
        } catch (error) {
          console.error(`è·å– ${token.symbol} ä½™é¢å¤±è´¥:`, error);
          return { symbol: token.symbol, balance: 0 };
        }
      });
      
      const balances = await Promise.all(balancePromises);
      
      balances.forEach(({ symbol, balance }) => {
        this.updateBalanceUI(symbol, balance);
      });
      
      const cfxBal = balances.find(b => b.symbol === 'CFX')?.balance || 0;
      const lomBal = balances.find(b => b.symbol === 'LOM')?.balance || 0;
      
      document.getElementById("addCfxBal").textContent = Utils.formatDisplay(cfxBal);
      document.getElementById("addLomBal").textContent = Utils.formatDisplay(lomBal);
      
      if (pair) {
        try {
          const lpBal = await pair.balanceOf(account);
          const removeBtn = document.getElementById("removeBtn");
          if (removeBtn) removeBtn.disabled = lpBal.isZero();
        } catch (error) {
          console.error("è·å–LPä½™é¢å¤±è´¥:", error);
        }
      }
      
    } catch (error) {
      console.error("æ›´æ–°ä½™é¢å¤±è´¥:", error);
    }
  },

  updateBalanceUI(symbol, balance) {
    const formattedBalance = Utils.formatDisplay(balance);
    
    if (symbol === fromToken) {
      const fromBalEl = document.getElementById('fromBal');
      if (fromBalEl) fromBalEl.textContent = formattedBalance;
    }
    
    if (symbol === toToken) {
      const toBalEl = document.getElementById('toBal');
      if (toBalEl) toBalEl.textContent = formattedBalance;
    }
  },

  async updatePoolInfo() {
    try {
      if (!pair || !account) return;
      
      const [r0, r1] = await pair.getReserves();
      const t0 = await pair.token0();
      const totalSupply = await pair.totalSupply();
      
      const reserveCfx = t0.toLowerCase() === APP_CONFIG.CONTRACTS.WCFX.toLowerCase() ? r0 : r1;
      const reserveLom = t0.toLowerCase() === APP_CONFIG.CONTRACTS.WCFX.toLowerCase() ? r1 : r0;
      
      const cfxReserve = parseFloat(ethers.utils.formatEther(reserveCfx));
      const lomReserve = parseFloat(ethers.utils.formatUnits(reserveLom, 18));
      
      currentReserves.cfx = cfxReserve;
      currentReserves.lom = lomReserve;
      
      const price = lomReserve / cfxReserve;
      currentRatio = price;
      
      const priceFormatted = Utils.formatDisplay(price);
      const priceElement = document.getElementById("price");
      if (priceElement) priceElement.textContent = `1 CFX = ${priceFormatted} LOM`;
      
      const addRatioElement = document.getElementById("addRatio");
      if (addRatioElement) addRatioElement.textContent = `1 CFX = ${priceFormatted} LOM`;

      const totalSupplyNum = parseFloat(ethers.utils.formatUnits(totalSupply, 18));
      
      let lpAmt = 0;
      let share = 0;
      let userCfx = 0;
      let userLom = 0;
      
      const lpBal = await pair.balanceOf(account);
      lpAmt = parseFloat(ethers.utils.formatUnits(lpBal, 18));
      
      if (totalSupplyNum > 0 && lpAmt > 0) {
        share = (lpAmt / totalSupplyNum) * 100;
        userCfx = cfxReserve * (share / 100);
        userLom = lomReserve * (share / 100);
      }
      
      const cfxReserveEl = document.getElementById("cfxReserve");
      const lomReserveEl = document.getElementById("lomReserve");
      
      if (cfxReserveEl) cfxReserveEl.textContent = cfxReserve.toFixed(2);
      if (lomReserveEl) lomReserveEl.textContent = lomReserve.toFixed(2);
      
      const userCfxEl = document.getElementById("userCfx");
      const userLomEl = document.getElementById("userLom");
      const userLpEl = document.getElementById("userLp");
      const userPoolShareEl = document.getElementById("userPoolShare");
      
      if (userCfxEl) userCfxEl.textContent = userCfx.toFixed(2);
      if (userLomEl) userLomEl.textContent = userLom.toFixed(2);
      if (userLpEl) userLpEl.textContent = lpAmt.toFixed(2);
      if (userPoolShareEl) userPoolShareEl.textContent = share.toFixed(4) + "%";
      
      const removeBtn = document.getElementById("removeBtn");
      if (removeBtn) {
        removeBtn.disabled = lpAmt <= 0;
      }
      
    } catch (error) {
      console.error("æ›´æ–°æ± å­ä¿¡æ¯å¤±è´¥:", error);
    }
  },

  updateSwapButtonState() {
    const swapBtn = document.getElementById("swapBtn");
    if (!swapBtn) return;
    
    const fromAmount = document.getElementById("fromAmount").value;
    
    if (!account) {
      swapBtn.textContent = isChinese ? "è¿æ¥é’±åŒ…" : "Connect Wallet";
      swapBtn.disabled = false;
      return;
    }
    
    if (!fromAmount || fromAmount === "0" || fromAmount === "") {
      swapBtn.textContent = isChinese ? "è¯·è¾“å…¥æ•°é‡" : "Enter Amount";
      swapBtn.disabled = true;
      return;
    }
    
    swapBtn.textContent = isChinese ? "ç«‹å³å…‘æ¢" : "Swap Now";
    swapBtn.disabled = false;
  },

  resetAllData() {
    const elements = {
      'fromBal': '0.000000',
      'toBal': '0.000000',
      'addCfxBal': '0.000000',
      'addLomBal': '0.000000',
      'price': '1 CFX = 0.000000 LOM',
      'minReceived': '0.000000 LOM'
    };
    
    Object.keys(elements).forEach(id => {
      const element = document.getElementById(id);
      if (element) element.textContent = elements[id];
    });
    
    const fromAmount = document.getElementById("fromAmount");
    const toAmount = document.getElementById("toAmount");
    if (fromAmount) fromAmount.value = "";
    if (toAmount) toAmount.value = "";
    
    const removeBtn = document.getElementById("removeBtn");
    if (removeBtn) removeBtn.disabled = true;
  }
};

// ==================== äº¤æ¢æ¨¡å— ====================
const SwapModule = {
  async executeSwap() {
    const fromAmount = document.getElementById('fromAmount').value;
    
    if (!fromAmount || fromAmount === '0') {
      Utils.showError(isChinese ? "è¯·è¾“å…¥å…‘æ¢æ•°é‡" : "Please enter swap amount");
      return;
    }
    
    try {
      Utils.showNotification(isChinese ? 'å¤„ç†å…‘æ¢ä¸­...' : 'Processing swap...', 'info');
      
      const amountIn = TokenUtils.parseTokenAmount(fromAmount, fromToken);
      const path = this.getSwapPath();
      
      const amounts = await router.getAmountsOut(amountIn, path);
      const minOut = amounts[amounts.length - 1].mul(1000 - slippage * 10).div(1000);
      
      const deadline = Math.floor(Date.now() / 1000) + 1200;
      
      let tx;
      
      if (fromToken === "CFX") {
        tx = await router.swapExactETHForTokensSupportingFeeOnTransferTokens(
          minOut, path, account, deadline, 
          { value: amountIn }
        );
      } else if (toToken === "CFX") {
        const tokenContract = TokenUtils.getTokenContract(fromToken);
        if (!tokenContract) throw new Error('ä»£å¸åˆçº¦æœªæ‰¾åˆ°');
        
        const allowance = await tokenContract.allowance(account, APP_CONFIG.CONTRACTS.ROUTER);
        if (allowance.lt(amountIn)) {
          Utils.showNotification(isChinese ? 'æˆæƒä»£å¸ä¸­...' : 'Approving token...', 'info');
          const approveTx = await tokenContract.approve(APP_CONFIG.CONTRACTS.ROUTER, ethers.constants.MaxUint256);
          await approveTx.wait();
        }
        
        tx = await router.swapExactTokensForETHSupportingFeeOnTransferTokens(
          amountIn, minOut, path, account, deadline
        );
      } else {
        const tokenContract = TokenUtils.getTokenContract(fromToken);
        if (!tokenContract) throw new Error('ä»£å¸åˆçº¦æœªæ‰¾åˆ°');
        
        const allowance = await tokenContract.allowance(account, APP_CONFIG.CONTRACTS.ROUTER);
        if (allowance.lt(amountIn)) {
          Utils.showNotification(isChinese ? 'æˆæƒä»£å¸ä¸­...' : 'Approving token...', 'info');
          const approveTx = await tokenContract.approve(APP_CONFIG.CONTRACTS.ROUTER, ethers.constants.MaxUint256);
          await approveTx.wait();
        }
        
        tx = await router.swapExactTokensForTokensSupportingFeeOnTransferTokens(
          amountIn, minOut, path, account, deadline
        );
      }
      
      await tx.wait();
      
      document.getElementById('fromAmount').value = '';
      document.getElementById('toAmount').value = '';
      
      Utils.showNotification(
        isChinese ? `å…‘æ¢æˆåŠŸï¼è·å¾— ${document.getElementById('toAmount').value} ${toToken}` : 
                   `Swap successful! Received ${document.getElementById('toAmount').value} ${toToken}`,
        'success'
      );
      
      await DataManager.refreshAll();
      await LPRewardManager.refreshAll();
      
    } catch (error) {
      console.error('å…‘æ¢å¤±è´¥:', error);
      Utils.showNotification(Utils.getErrorMessage(error), 'error');
    }
  },

  getSwapPath() {
    let path = [];
    
    if ((fromToken === 'AXCNH' && toToken === 'USDT0') || 
        (fromToken === 'USDT0' && toToken === 'AXCNH')) {
      
      if (fromToken === 'AXCNH') {
        path.push(APP_CONFIG.CONTRACTS.AXCNH);
        path.push(APP_CONFIG.CONTRACTS.USDT0);
      } else {
        path.push(APP_CONFIG.CONTRACTS.USDT0);
        path.push(APP_CONFIG.CONTRACTS.AXCNH);
      }
      return path;
    }
    
    if (fromToken === 'CFX') {
      path.push(APP_CONFIG.CONTRACTS.WCFX);
      if (toToken === 'LOM') path.push(APP_CONFIG.CONTRACTS.LOM);
      else if (toToken === 'USDC') path.push(APP_CONFIG.CONTRACTS.USDC);
      else if (toToken === 'AXCNH') path.push(APP_CONFIG.CONTRACTS.AXCNH);
      else if (toToken === 'USDT0') path.push(APP_CONFIG.CONTRACTS.USDT0);
      else if (toToken === 'CNHT0') path.push(APP_CONFIG.CONTRACTS.CNHT0);
    } else if (toToken === 'CFX') {
      if (fromToken === 'LOM') path.push(APP_CONFIG.CONTRACTS.LOM);
      else if (fromToken === 'USDC') path.push(APP_CONFIG.CONTRACTS.USDC);
      else if (fromToken === 'AXCNH') path.push(APP_CONFIG.CONTRACTS.AXCNH);
      else if (fromToken === 'USDT0') path.push(APP_CONFIG.CONTRACTS.USDT0);
      else if (fromToken === 'CNHT0') path.push(APP_CONFIG.CONTRACTS.CNHT0);
      path.push(APP_CONFIG.CONTRACTS.WCFX);
    } else {
      if (fromToken === 'LOM') path.push(APP_CONFIG.CONTRACTS.LOM);
      else if (fromToken === 'USDC') path.push(APP_CONFIG.CONTRACTS.USDC);
      else if (fromToken === 'AXCNH') path.push(APP_CONFIG.CONTRACTS.AXCNH);
      else if (fromToken === 'USDT0') path.push(APP_CONFIG.CONTRACTS.USDT0);
      else if (fromToken === 'CNHT0') path.push(APP_CONFIG.CONTRACTS.CNHT0);
      
      path.push(APP_CONFIG.CONTRACTS.WCFX);
      
      if (toToken === 'LOM') path.push(APP_CONFIG.CONTRACTS.LOM);
      else if (toToken === 'USDC') path.push(APP_CONFIG.CONTRACTS.USDC);
      else if (toToken === 'AXCNH') path.push(APP_CONFIG.CONTRACTS.AXCNH);
      else if (toToken === 'USDT0') path.push(APP_CONFIG.CONTRACTS.USDT0);
      else if (toToken === 'CNHT0') path.push(APP_CONFIG.CONTRACTS.CNHT0);
    }
    
    return path;
  },

  async updateOutputFromInput() {
    const amount = document.getElementById('fromAmount').value;
    
    if (!amount || amount === '0' || amount === '' || !router) {
      document.getElementById('toAmount').value = "";
      document.getElementById('minReceived').textContent = `0 ${toToken}`;
      DataManager.updateSwapButtonState();
      return;
    }
    
    try {
      const amountIn = TokenUtils.parseTokenAmount(amount, fromToken);
      const path = this.getSwapPath();
      
      const amounts = await router.getAmountsOut(amountIn, path);
      const out = TokenUtils.formatTokenAmount(amounts[amounts.length - 1], toToken);
      
      document.getElementById('toAmount').value = out;
      
      const minOut = amounts[amounts.length - 1].mul(1000 - slippage * 10).div(1000);
      const minOutFormatted = TokenUtils.formatTokenAmount(minOut, toToken);
      document.getElementById('minReceived').textContent = 
        `${minOutFormatted} ${toToken}`;
      
      const price = parseFloat(out) / parseFloat(amount);
      const priceFormatted = Utils.formatDisplay(price);
      document.getElementById('price').textContent = 
        `1 ${fromToken} = ${priceFormatted} ${toToken}`;
      
      DataManager.updateSwapButtonState();
      
    } catch (error) {
      console.error('è®¡ç®—è¾“å‡ºå¤±è´¥:', error);
      document.getElementById('toAmount').value = "";
      const swapBtn = document.getElementById('swapBtn');
      if (swapBtn) {
        swapBtn.textContent = isChinese ? 'è®¡ç®—å¤±è´¥' : 'Calculation Failed';
        swapBtn.disabled = true;
      }
    }
  }
};

// ==================== æµåŠ¨æ€§æ¨¡å— ====================
const LiquidityModule = {
  async addLiquidity() {
    const cfxAmount = document.getElementById("addCfx").value;
    const lomAmount = document.getElementById("addLom").value;
    
    if (!cfxAmount || !lomAmount || parseFloat(cfxAmount) <= 0 || parseFloat(lomAmount) <= 0) {
      Utils.showError(isChinese ? "è¯·è¾“å…¥æœ‰æ•ˆæ•°é‡" : "Please enter valid amounts");
      return;
    }
    
    try {
      Utils.showNotification(isChinese ? 'æ·»åŠ æµåŠ¨æ€§ä¸­...' : 'Adding liquidity...', 'info');
      
      const amountCfx = TokenUtils.parseTokenAmount(cfxAmount, 'CFX');
      const amountLom = TokenUtils.parseTokenAmount(lomAmount, 'LOM');
      
      const allowance = await lom.allowance(account, APP_CONFIG.CONTRACTS.ROUTER);
      if (allowance.lt(amountLom)) {
        Utils.showNotification(isChinese ? 'æˆæƒLOMä¸­...' : 'Approving LOM...', 'info');
        const approveTx = await lom.approve(APP_CONFIG.CONTRACTS.ROUTER, ethers.constants.MaxUint256);
        await approveTx.wait();
      }
      
      const minCfx = amountCfx.mul(1000 - slippage * 10).div(1000);
      const minLom = amountLom.mul(1000 - slippage * 10).div(1000);
      const deadline = Math.floor(Date.now() / 1000) + 1800;
      
      const tx = await router.addLiquidityETH(
        APP_CONFIG.CONTRACTS.LOM,
        amountLom,
        minLom,
        minCfx,
        account,
        deadline,
        { value: amountCfx }
      );
      
      await tx.wait();
      
      document.getElementById("addModal").style.display = "none";
      document.getElementById("addCfx").value = "";
      document.getElementById("addLom").value = "";
      
      Utils.showNotification(isChinese ? 'æ·»åŠ æµåŠ¨æ€§æˆåŠŸï¼' : 'Liquidity added successfully!', 'success');
      
      // å…³é”®ä¿®å¤ï¼šç­‰å¾…å¹¶åŒæ­¥åˆçº¦ä»½é¢
      await new Promise(resolve => setTimeout(resolve, 2000));
      await LPRewardManager.syncContractShares();
      await DataManager.refreshAll();
      await LPRewardManager.refreshAll();
      
    } catch (error) {
      console.error('æ·»åŠ æµåŠ¨æ€§å¤±è´¥:', error);
      Utils.showNotification(Utils.getErrorMessage(error), 'error');
    }
  },

  async removeLiquidity() {
    const percent = document.getElementById("removeSlider").value;
    
    try {
      Utils.showNotification(isChinese ? 'ç§»é™¤æµåŠ¨æ€§ä¸­...' : 'Removing liquidity...', 'info');
      
      const lpBal = await pair.balanceOf(account);
      const liquidity = lpBal.mul(percent).div(100);
      
      if (liquidity.isZero()) {
        throw new Error(isChinese ? 'æ²¡æœ‰æµåŠ¨æ€§å¯ç§»é™¤' : 'No liquidity to remove');
      }
      
      const allowance = await pair.allowance(account, APP_CONFIG.CONTRACTS.ROUTER);
      if (allowance.lt(liquidity)) {
        Utils.showNotification(isChinese ? 'æˆæƒLPä»£å¸ä¸­...' : 'Approving LP token...', 'info');
        const approveTx = await pair.approve(APP_CONFIG.CONTRACTS.ROUTER, ethers.constants.MaxUint256);
        await approveTx.wait();
      }
      
      const deadline = Math.floor(Date.now() / 1000) + 1800;
      
      const tx = await router.removeLiquidityETH(
        APP_CONFIG.CONTRACTS.LOM, 
        liquidity, 
        0,
        0,
        account, 
        deadline
      );
      
      await tx.wait();
      
      document.getElementById("removeModal").style.display = "none";
      
      const cfxEst = document.getElementById("removeEstCfx").textContent;
      const lomEst = document.getElementById("removeEstLom").textContent;
      
      Utils.showNotification(
        isChinese ? `ç§»é™¤æµåŠ¨æ€§æˆåŠŸï¼è·å¾— ${cfxEst} CFX å’Œ ${lomEst} LOM` : 
                   `Success! Received ${cfxEst} CFX and ${lomEst} LOM`,
        'success'
      );
      
      // å…³é”®ä¿®å¤ï¼šç­‰å¾…å¹¶åŒæ­¥åˆçº¦ä»½é¢
      await new Promise(resolve => setTimeout(resolve, 2000));
      await LPRewardManager.syncContractShares();
      await DataManager.refreshAll();
      await LPRewardManager.refreshAll();
      
    } catch (error) {
      console.error('ç§»é™¤æµåŠ¨æ€§å¤±è´¥:', error);
      Utils.showNotification(Utils.getErrorMessage(error), 'error');
    }
  },

  async updateRemoveEstimate(percent) {
    try {
      if (!account || !pair) return;
      
      document.getElementById("removePercent").textContent = percent + "%";
      
      const lpBal = await pair.balanceOf(account);
      const liquidity = lpBal.mul(percent).div(100);
      
      if (liquidity.isZero()) {
        document.getElementById("removeEstCfx").textContent = "0.000000";
        document.getElementById("removeEstLom").textContent = "0.000000";
        return;
      }
      
      const total = await pair.totalSupply();
      const { cfx: rCfx, lom: rLom } = currentReserves;
      
      const cfxReserve = TokenUtils.parseTokenAmount(rCfx.toString(), 'CFX');
      const lomReserve = TokenUtils.parseTokenAmount(rLom.toString(), 'LOM');
      
      const cfxOut = cfxReserve.mul(liquidity).div(total);
      const lomOut = lomReserve.mul(liquidity).div(total);
      
      const cfxOutFormatted = TokenUtils.formatTokenAmount(cfxOut, 'CFX');
      const lomOutFormatted = TokenUtils.formatTokenAmount(lomOut, 'LOM');
      
      document.getElementById("removeEstCfx").textContent = cfxOutFormatted;
      document.getElementById("removeEstLom").textContent = lomOutFormatted;
      
    } catch (error) {
      console.error("æ›´æ–°ç§»é™¤ä¼°ç®—å¤±è´¥:", error);
      document.getElementById("removeEstCfx").textContent = "0.000000";
      document.getElementById("removeEstLom").textContent = "0.000000";
    }
  },

  updateAddButtonState() {
    const cfxAmount = document.getElementById("addCfx").value;
    const lomAmount = document.getElementById("addLom").value;
    const cfxBalance = parseFloat(document.getElementById("addCfxBal").textContent);
    const lomBalance = parseFloat(document.getElementById("addLomBal").textContent);
    const confirmButton = document.getElementById("confirmAddBtn");
    
    if (!confirmButton) return;
    
    if (!cfxAmount || !lomAmount || cfxAmount === "" || lomAmount === "") {
      confirmButton.disabled = true;
      return;
    }
    
    const cfxNum = parseFloat(cfxAmount);
    const lomNum = parseFloat(lomAmount);
    
    if (isNaN(cfxNum) || isNaN(lomNum) || cfxNum <= 0 || lomNum <= 0) {
      confirmButton.disabled = true;
      return;
    }
    
    if (cfxNum > cfxBalance) {
      confirmButton.disabled = true;
      return;
    }
    
    if (lomNum > lomBalance) {
      confirmButton.disabled = true;
      return;
    }
    
    const remainingCfx = cfxBalance - cfxNum;
    if (remainingCfx < 0.01) {
      confirmButton.disabled = true;
      return;
    }
    
    confirmButton.disabled = false;
  },

  async setMaxCfx() {
    const cfxBal = parseFloat(document.getElementById("addCfxBal").textContent);
    if (cfxBal <= 0) {
      Utils.showError(isChinese ? "CFXä½™é¢ä¸è¶³" : "Insufficient CFX balance");
      return;
    }
    
    const maxCfx = Math.max(0, cfxBal - 0.1);
    document.getElementById("addCfx").value = Utils.formatDisplay(maxCfx);
    
    if (currentRatio > 0) {
      const requiredLom = maxCfx * currentRatio;
      const lomBal = parseFloat(document.getElementById("addLomBal").textContent);
      
      if (requiredLom <= lomBal) {
        document.getElementById("addLom").value = Utils.formatDisplay(requiredLom);
      } else {
        const adjustedCfx = lomBal / currentRatio;
        document.getElementById("addCfx").value = Utils.formatDisplay(Math.min(adjustedCfx, maxCfx));
        document.getElementById("addLom").value = Utils.formatDisplay(lomBal);
      }
    }
    
    this.updateAddButtonState();
  },

  async setMaxLom() {
    const lomBal = parseFloat(document.getElementById("addLomBal").textContent);
    if (lomBal <= 0) {
      Utils.showError(isChinese ? "LOMä½™é¢ä¸è¶³" : "Insufficient LOM balance");
      return;
    }
    
    document.getElementById("addLom").value = Utils.formatDisplay(lomBal);
    
    if (currentRatio > 0) {
      const requiredCfx = lomBal / currentRatio;
      const cfxBal = parseFloat(document.getElementById("addCfxBal").textContent);
      const availableCfx = Math.max(0, cfxBal - 0.1);
      
      if (requiredCfx <= availableCfx) {
        document.getElementById("addCfx").value = Utils.formatDisplay(requiredCfx);
      } else {
        const adjustedLom = availableCfx * currentRatio;
        document.getElementById("addLom").value = Utils.formatDisplay(Math.min(adjustedLom, lomBal));
        document.getElementById("addCfx").value = Utils.formatDisplay(availableCfx);
      }
    }
    
    this.updateAddButtonState();
  }
};

// ==================== UIäº‹ä»¶å¤„ç†å™¨ ====================
const EventHandlers = {
  init() {
    this.setupWalletEvents();
    this.setupSwapEvents();
    this.setupLiquidityEvents();
    this.setupLPRewardEvents();
    this.setupModalEvents();
    this.setupTabEvents();
    this.setupLanguageToggle();
    this.setupProjectIntro();
  },

  setupLPRewardEvents() {
    const activateBtn = document.getElementById("activateBtn");
    if (activateBtn) {
      activateBtn.addEventListener("click", async () => {
        await LPRewardManager.activate();
      });
    }
    
    const claimBtn = document.getElementById("claimBtn");
    if (claimBtn) {
      claimBtn.addEventListener("click", () => {
        LPRewardManager.claimReward();
      });
    }
    
    const claimReferralBtn = document.getElementById("claimReferralBtn");
    if (claimReferralBtn) {
      claimReferralBtn.addEventListener("click", () => {
        LPRewardManager.claimReferralReward();
      });
    }
    
    const referrerInput = document.getElementById("referrerAddress");
    if (referrerInput) {
      referrerInput.addEventListener("input", Utils.debounce(() => {
        const address = referrerInput.value.trim();
        if (address && !Utils.isValidAddress(address)) {
          referrerInput.style.borderColor = "var(--accent-red)";
          referrerInput.style.background = "rgba(255, 71, 87, 0.05)";
        } else {
          referrerInput.style.borderColor = "";
          referrerInput.style.background = "";
        }
      }, 500));
    }
  },

  setupWalletEvents() {
    const walletBtn = document.getElementById("walletBtn");
    if (!walletBtn) return;
    
    walletBtn.addEventListener("click", async () => {
      if (account) {
        if (confirm(isChinese ? "ç¡®å®šè¦æ–­å¼€é’±åŒ…è¿æ¥å—ï¼Ÿ" : "Are you sure you want to disconnect wallet?")) {
          AppCore.disconnect();
        }
        return;
      }
      
      walletBtn.disabled = true;
      try {
        const success = await AppCore.connectWallet();
        if (success) {
          DataManager.refreshAll();
          LPRewardManager.refreshAll();
          LPRewardManager.startAutoRefresh();
        }
      } finally {
        walletBtn.disabled = false;
      }
    });
  },

  setupSwapEvents() {
    const fromAmount = document.getElementById("fromAmount");
    if (!fromAmount) return;
    
    const debouncedFromInput = Utils.debounce(() => {
      const amount = fromAmount.value;
      if (amount && amount !== "0") {
        lastInputWasFrom = true;
        SwapModule.updateOutputFromInput();
      } else {
        const toAmount = document.getElementById("toAmount");
        if (toAmount) toAmount.value = "";
        DataManager.updateSwapButtonState();
        const minReceived = document.getElementById("minReceived");
        if (minReceived) minReceived.textContent = `0.000000 ${toToken}`;
      }
    }, 300);
    
    fromAmount.addEventListener("input", debouncedFromInput);
    
    const reverseBtn = document.getElementById("reverse");
    if (reverseBtn) {
      reverseBtn.addEventListener("click", () => {
        const tempToken = fromToken;
        fromToken = toToken;
        toToken = tempToken;
        
        const fromTokenSymbol = document.getElementById("fromTokenSymbol");
        const toTokenSymbol = document.getElementById("toTokenSymbol");
        if (fromTokenSymbol) fromTokenSymbol.textContent = fromToken;
        if (toTokenSymbol) toTokenSymbol.textContent = toToken;
        
        const fromTokenData = TokenUtils.getToken(fromToken);
        const toTokenData = TokenUtils.getToken(toToken);
        
        const fromTokenLogo = document.getElementById("fromTokenLogo");
        const toTokenLogo = document.getElementById("toTokenLogo");
        
        if (fromTokenData && fromTokenLogo) {
          fromTokenLogo.style.backgroundImage = `url('${fromTokenData.logo}')`;
        }
        
        if (toTokenData && toTokenLogo) {
          toTokenLogo.style.backgroundImage = `url('${toTokenData.logo}')`;
        }
        
        if (fromAmount) fromAmount.value = "";
        const toAmount = document.getElementById("toAmount");
        if (toAmount) toAmount.value = "";
        
        DataManager.updateAllBalances();
        DataManager.updateSwapButtonState();
        const price = document.getElementById("price");
        if (price) price.textContent = `1 ${fromToken} = 0.000000 ${toToken}`;
        const minReceived = document.getElementById("minReceived");
        if (minReceived) minReceived.textContent = `0.000000 ${toToken}`;
        
        lastInputWasFrom = true;
      });
    }
    
    const swapBtn = document.getElementById("swapBtn");
    if (swapBtn) {
      swapBtn.addEventListener("click", async () => {
        if (!account) {
          await AppCore.connectWallet();
        } else {
          await SwapModule.executeSwap();
        }
      });
    }
    
    document.querySelectorAll('.percent-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const percent = parseFloat(e.target.dataset.percent);
        document.querySelectorAll('.percent-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        
        if (!account) {
          Utils.showError(isChinese ? "è¯·å…ˆè¿æ¥é’±åŒ…" : "Please connect wallet first");
          return;
        }
        
        const fromBal = document.getElementById("fromBal");
        if (!fromBal) return;
        
        let balance = parseFloat(fromBal.textContent);
        if (balance > 0) {
          let amount;
          if (percent === 1) {
            amount = fromToken === 'CFX' ? Math.max(0, balance - 0.1) : balance * 0.9;
          } else {
            amount = balance * percent;
          }
          
          if (amount > 0) {
            if (fromAmount) fromAmount.value = Utils.formatDisplay(amount);
            lastInputWasFrom = true;
            SwapModule.updateOutputFromInput();
          }
        }
      });
    });
    
    document.querySelectorAll('.slippage-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const newSlippage = parseFloat(e.target.dataset.slip);
        if (fromToken === 'LOM' && newSlippage < 5) {
          Utils.showNotification(
            isChinese ? 'LOMäº¤æ˜“éœ€è¦5%ä»¥ä¸Šæ»‘ç‚¹ä»¥é¿å…äº¤æ˜“å¤±è´¥' : 
                      'LOM transactions require 5%+ slippage to avoid failure',
            'warning'
          );
        }
        
        slippage = newSlippage;
        document.querySelectorAll('.slippage-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        
        if (lastInputWasFrom && fromAmount && fromAmount.value) {
          SwapModule.updateOutputFromInput();
        }
      });
    });
    
    const fromTokenSelector = document.getElementById("fromTokenSelector");
    const toTokenSelector = document.getElementById("toTokenSelector");
    
    if (fromTokenSelector) {
      fromTokenSelector.addEventListener("click", () => this.openTokenSelector('from'));
    }
    
    if (toTokenSelector) {
      toTokenSelector.addEventListener("click", () => this.openTokenSelector('to'));
    }
  },

  setupLiquidityEvents() {
    const addBtn = document.getElementById("addBtn");
    if (addBtn) {
      addBtn.addEventListener("click", () => {
        if (!account) {
          Utils.showError(isChinese ? "è¯·å…ˆè¿æ¥é’±åŒ…" : "Please connect wallet first");
          return;
        }
        
        const addModal = document.getElementById("addModal");
        if (addModal) addModal.style.display = "flex";
        
        const addCfx = document.getElementById("addCfx");
        const addLom = document.getElementById("addLom");
        if (addCfx) addCfx.value = "";
        if (addLom) addLom.value = "";
        
        const confirmAddBtn = document.getElementById("confirmAddBtn");
        if (confirmAddBtn) confirmAddBtn.disabled = true;
        
        if (currentRatio > 0) {
          const ratioFormatted = Utils.formatDisplay(currentRatio);
          const addRatio = document.getElementById("addRatio");
          if (addRatio) addRatio.textContent = `1 CFX = ${ratioFormatted} LOM`;
        }
      });
    }
    
    const removeBtn = document.getElementById("removeBtn");
    if (removeBtn) {
      removeBtn.addEventListener("click", () => {
        if (!account) {
          Utils.showError(isChinese ? "è¯·å…ˆè¿æ¥é’±åŒ…" : "Please connect wallet first");
          return;
        }
        
        const removeModal = document.getElementById("removeModal");
        if (removeModal) removeModal.style.display = "flex";
        LiquidityModule.updateRemoveEstimate(100);
      });
    }
    
    const addCfx = document.getElementById("addCfx");
    const addLom = document.getElementById("addLom");
    
    if (addCfx) {
      const debouncedCfxInput = Utils.debounce(() => {
        const cfxAmount = addCfx.value;
        if (!cfxAmount || cfxAmount === "" || parseFloat(cfxAmount) <= 0) {
          if (addLom) addLom.value = "";
          const confirmAddBtn = document.getElementById("confirmAddBtn");
          if (confirmAddBtn) confirmAddBtn.disabled = true;
          return;
        }
        
        if (currentRatio > 0) {
          const cfxNum = parseFloat(cfxAmount);
          const lomAmount = cfxNum * currentRatio;
          if (addLom) addLom.value = Utils.formatDisplay(lomAmount);
        }
        
        LiquidityModule.updateAddButtonState();
      }, 300);
      
      addCfx.addEventListener("input", debouncedCfxInput);
    }
    
    if (addLom) {
      const debouncedLomInput = Utils.debounce(() => {
        const lomAmount = addLom.value;
        if (!lomAmount || lomAmount === "" || parseFloat(lomAmount) <= 0) {
          if (addCfx) addCfx.value = "";
          const confirmAddBtn = document.getElementById("confirmAddBtn");
          if (confirmAddBtn) confirmAddBtn.disabled = true;
          return;
        }
        
        if (currentRatio > 0) {
          const lomNum = parseFloat(lomAmount);
          const cfxAmount = lomNum / currentRatio;
          if (addCfx) addCfx.value = Utils.formatDisplay(cfxAmount);
        }
        
        LiquidityModule.updateAddButtonState();
      }, 300);
      
      addLom.addEventListener("input", debouncedLomInput);
    }
    
    const cfxMaxBtn = document.getElementById("cfxMaxBtn");
    if (cfxMaxBtn) {
      cfxMaxBtn.addEventListener("click", () => LiquidityModule.setMaxCfx());
    }
    
    const lomMaxBtn = document.getElementById("lomMaxBtn");
    if (lomMaxBtn) {
      lomMaxBtn.addEventListener("click", () => LiquidityModule.setMaxLom());
    }
    
    const cancelAddBtn = document.getElementById("cancelAddBtn");
    if (cancelAddBtn) {
      cancelAddBtn.addEventListener("click", () => {
        const addModal = document.getElementById("addModal");
        if (addModal) addModal.style.display = "none";
      });
    }
    
    const confirmAddBtn = document.getElementById("confirmAddBtn");
    if (confirmAddBtn) {
      confirmAddBtn.addEventListener("click", async () => {
        await LiquidityModule.addLiquidity();
      });
    }
    
    const removeSlider = document.getElementById("removeSlider");
    if (removeSlider) {
      removeSlider.addEventListener("input", (e) => {
        LiquidityModule.updateRemoveEstimate(e.target.value);
      });
    }
    
    document.querySelectorAll('.percentage-option').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const percent = e.target.dataset.percent;
        document.querySelectorAll('.percentage-option').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        if (removeSlider) removeSlider.value = percent;
        const removePercent = document.getElementById("removePercent");
        if (removePercent) removePercent.textContent = percent + "%";
        LiquidityModule.updateRemoveEstimate(percent);
      });
    });
    
    const cancelRemoveBtn = document.getElementById("cancelRemoveBtn");
    if (cancelRemoveBtn) {
      cancelRemoveBtn.addEventListener("click", () => {
        const removeModal = document.getElementById("removeModal");
        if (removeModal) removeModal.style.display = "none";
      });
    }
    
    const confirmRemoveBtn = document.getElementById("confirmRemoveBtn");
    if (confirmRemoveBtn) {
      confirmRemoveBtn.addEventListener("click", async () => {
        await LiquidityModule.removeLiquidity();
      });
    }
  },

  setupModalEvents() {
    document.addEventListener("click", (e) => {
      if (e.target.classList.contains("modal-overlay") || 
          e.target.classList.contains("token-selector-modal") ||
          e.target.classList.contains("simple-confirm-modal")) {
        e.target.style.display = "none";
      }
    });
    
    const txStatusDoneBtn = document.getElementById('txStatusDoneBtn');
    if (txStatusDoneBtn) {
      txStatusDoneBtn.addEventListener('click', () => {
        Utils.hideNotification();
      });
    }
  },

  setupTabEvents() {
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        const tabId = btn.dataset.tab;
        
        tabBtns.forEach(b => b.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));
        
        btn.classList.add('active');
        const tabContent = document.getElementById(tabId + 'Tab');
        if (tabContent) tabContent.classList.add('active');
        
        if (account) {
          DataManager.refreshAll();
          if (tabId === 'lpReward') {
            LPRewardManager.refreshAll();
          }
        }
      });
    });
  },

  setupLanguageToggle() {
    const langBtn = document.getElementById("langBtn");
    if (langBtn) {
      langBtn.addEventListener("click", () => {
        isChinese = !isChinese;
        langBtn.innerText = isChinese ? "EN" : "ZH";
        this.updateAllTexts();
      });
    }
  },

  setupProjectIntro() {
    const logoContainer = document.getElementById("logoContainer");
    if (logoContainer) {
      logoContainer.addEventListener("click", () => {
        const projectIntroOverlay = document.getElementById("projectIntroOverlay");
        if (projectIntroOverlay) projectIntroOverlay.style.display = "flex";
      });
    }
    
    const closeBtn = document.getElementById("projectIntroCloseBtn");
    if (closeBtn) {
      closeBtn.addEventListener("click", () => {
        const projectIntroOverlay = document.getElementById("projectIntroOverlay");
        if (projectIntroOverlay) projectIntroOverlay.style.display = "none";
      });
    }
  },

  updateAllTexts() {
    const walletBtn = document.getElementById("walletBtn");
    if (account) {
      const displayAddress = Utils.formatAddress(account);
      if (walletBtn) {
        walletBtn.textContent = displayAddress;
        walletBtn.classList.add('connected');
      }
    } else {
      if (walletBtn) {
        walletBtn.textContent = isChinese ? "è¿æ¥é’±åŒ…" : "Connect Wallet";
        walletBtn.classList.remove('connected');
      }
    }
    
    const swapTabBtn = document.querySelector('[data-tab="swap"]');
    const liquidityTabBtn = document.querySelector('[data-tab="liquidity"]');
    const lpRewardTabBtn = document.querySelector('[data-tab="lpReward"]');
    
    if (swapTabBtn) swapTabBtn.textContent = isChinese ? "å…‘æ¢" : "Swap";
    if (liquidityTabBtn) liquidityTabBtn.textContent = isChinese ? "æµåŠ¨æ€§" : "Liquidity";
    if (lpRewardTabBtn) lpRewardTabBtn.textContent = isChinese ? "LPå¥–åŠ±" : "LP Reward";
    
    const swapBtn = document.getElementById("swapBtn");
    if (swapBtn) {
      if (!account) {
        swapBtn.textContent = isChinese ? "è¿æ¥é’±åŒ…" : "Connect Wallet";
        swapBtn.disabled = false;
      } else if (document.getElementById("fromAmount") && document.getElementById("fromAmount").value && document.getElementById("fromAmount").value !== "0") {
        swapBtn.textContent = isChinese ? "ç«‹å³å…‘æ¢" : "Swap Now";
        swapBtn.disabled = false;
      } else {
        swapBtn.textContent = isChinese ? "è¯·è¾“å…¥æ•°é‡" : "Enter Amount";
        swapBtn.disabled = true;
      }
    }
    
    const addBtn = document.getElementById("addBtn");
    const removeBtn = document.getElementById("removeBtn");
    if (addBtn) addBtn.textContent = isChinese ? "æ·»åŠ æµåŠ¨æ€§" : "Add Liquidity";
    if (removeBtn) removeBtn.textContent = isChinese ? "ç§»é™¤æµåŠ¨æ€§" : "Remove Liquidity";
    
    const tokenSelectorTitle = document.getElementById("tokenSelectorTitle");
    const addTitle = document.getElementById("addTitle");
    const removeTitle = document.getElementById("removeTitle");
    const confirmAddBtn = document.getElementById("confirmAddBtn");
    const confirmRemoveBtn = document.getElementById("confirmRemoveBtn");
    const cancelAddBtn = document.getElementById("cancelAddBtn");
    const cancelRemoveBtn = document.getElementById("cancelRemoveBtn");
    
    if (tokenSelectorTitle) tokenSelectorTitle.textContent = isChinese ? "é€‰æ‹©ä»£å¸" : "Select Token";
    if (addTitle) addTitle.textContent = isChinese ? "æ·»åŠ æµåŠ¨æ€§" : "Add Liquidity";
    if (removeTitle) removeTitle.textContent = isChinese ? "ç§»é™¤æµåŠ¨æ€§" : "Remove Liquidity";
    if (confirmAddBtn) confirmAddBtn.textContent = isChinese ? "ç¡®è®¤æ·»åŠ " : "Confirm Add";
    if (confirmRemoveBtn) confirmRemoveBtn.textContent = isChinese ? "ç¡®è®¤ç§»é™¤" : "Confirm Remove";
    if (cancelAddBtn) cancelAddBtn.textContent = isChinese ? "å–æ¶ˆ" : "Cancel";
    if (cancelRemoveBtn) cancelRemoveBtn.textContent = isChinese ? "å–æ¶ˆ" : "Cancel";
    
    const riskTitle = document.getElementById("riskTitle");
    const riskText = document.getElementById("riskText");
    if (riskTitle) riskTitle.textContent = isChinese ? "é£é™©æç¤º" : "Risk Warning";
    if (riskText) riskText.textContent = isChinese ? 
      "æœ¬åº”ç”¨ä»…ä½œä¸ºæŠ€æœ¯æ¼”ç¤ºï¼Œä¸æ„æˆä»»ä½•æŠ•èµ„å»ºè®®ã€‚åŠ å¯†è´§å¸å¸‚åœºæ³¢åŠ¨å·¨å¤§ï¼ŒæŠ•èµ„éœ€è°¨æ…ï¼Œè¯·ç†æ€§å¯¹å¾…æ•°å­—èµ„äº§äº¤æ˜“ã€‚" :
      "This application is for technical demonstration only and does not constitute investment advice. The cryptocurrency market is highly volatile. Please invest cautiously and treat digital asset trading rationally.";
    
    const footerText = document.getElementById("footerText");
    if (footerText) footerText.textContent = isChinese ? "LOMswap Â· Conflux eSpace" : "LOMswap Â· Conflux eSpace";
  },

  openTokenSelector(type) {
    currentTokenSelector = type;
    const modal = document.getElementById("tokenSelectorModal");
    if (modal) modal.style.display = "flex";
    const tokenSearch = document.getElementById("tokenSearch");
    if (tokenSearch) tokenSearch.value = "";
    this.populateTokenList();
  },

  async populateTokenList(searchTerm = "") {
    const tokenList = document.getElementById("tokenList");
    if (!tokenList) return;
    
    tokenList.innerHTML = "";
    
    const filteredTokens = TOKEN_LIST.filter(token => {
      if (searchTerm) {
        const term = searchTerm.toLowerCase();
        return token.symbol.toLowerCase().includes(term) || 
               token.name.toLowerCase().includes(term);
      }
      return true;
    });
    
    const fragment = document.createDocumentFragment();
    
    filteredTokens.forEach(token => {
      if ((currentTokenSelector === 'from' && token.symbol === toToken) ||
          (currentTokenSelector === 'to' && token.symbol === fromToken)) {
        return;
      }
      
      const tokenItem = document.createElement("div");
      tokenItem.className = "token-item";
      tokenItem.innerHTML = `
        <div class="token-item-logo" style="background-image: url('${token.logo}')"></div>
        <div class="token-item-info">
          <div class="token-item-symbol">${token.symbol}</div>
          <div class="token-item-name">${token.name}</div>
        </div>
        <div class="token-item-balance" id="selectorBalance-${token.symbol}">0.000000</div>
      `;
      
      tokenItem.addEventListener("click", () => {
        this.selectToken(token);
      });
      
      fragment.appendChild(tokenItem);
    });
    
    tokenList.appendChild(fragment);
    
    setTimeout(() => {
      if (account) {
        filteredTokens.forEach(token => {
          this.updateTokenBalanceInSelector(token.symbol);
        });
      }
    }, 50);
    
    const searchInput = document.getElementById("tokenSearch");
    if (searchInput) {
      const debouncedSearch = Utils.debounce((e) => {
        this.populateTokenList(e.target.value);
      }, 300);
      
      searchInput.removeEventListener('input', searchInput._debouncedHandler);
      searchInput._debouncedHandler = debouncedSearch;
      searchInput.addEventListener('input', searchInput._debouncedHandler);
      
      setTimeout(() => searchInput.focus(), 100);
    }
  },

  handleSearchInput: null,

  async updateTokenBalanceInSelector(symbol) {
    try {
      const token = TokenUtils.getToken(symbol);
      if (!token) return;
      
      let amount = 0;
      
      if (symbol === 'CFX' && provider && account) {
        const cfxBal = await provider.getBalance(account);
        amount = parseFloat(ethers.utils.formatEther(cfxBal));
      } else {
        const contract = TokenUtils.getTokenContract(symbol);
        if (contract && account) {
          const tokenBal = await contract.balanceOf(account);
          amount = parseFloat(ethers.utils.formatUnits(tokenBal, token.decimals));
        }
      }
      
      const formattedBalance = Utils.formatDisplay(amount);
      const balanceElement = document.getElementById(`selectorBalance-${symbol}`);
      if (balanceElement) {
        balanceElement.textContent = formattedBalance;
      }
    } catch (error) {
      console.error(`æ›´æ–°${symbol}ä½™é¢å¤±è´¥:`, error);
    }
  },

  selectToken(token) {
    if (currentTokenSelector === 'from') {
      fromToken = token.symbol;
      const fromTokenSymbol = document.getElementById("fromTokenSymbol");
      const fromTokenLogo = document.getElementById("fromTokenLogo");
      if (fromTokenSymbol) fromTokenSymbol.textContent = token.symbol;
      if (fromTokenLogo) fromTokenLogo.style.backgroundImage = `url('${token.logo}')`;
    } else if (currentTokenSelector === 'to') {
      toToken = token.symbol;
      const toTokenSymbol = document.getElementById("toTokenSymbol");
      const toTokenLogo = document.getElementById("toTokenLogo");
      if (toTokenSymbol) toTokenSymbol.textContent = token.symbol;
      if (toTokenLogo) toTokenLogo.style.backgroundImage = `url('${token.logo}')`;
    }
    
    const tokenSelectorModal = document.getElementById("tokenSelectorModal");
    if (tokenSelectorModal) tokenSelectorModal.style.display = "none";
    DataManager.updateAllBalances();
    
    const fromAmount = document.getElementById("fromAmount");
    const toAmount = document.getElementById("toAmount");
    if (fromAmount) fromAmount.value = "";
    if (toAmount) toAmount.value = "";
    
    DataManager.updateSwapButtonState();
    const price = document.getElementById("price");
    if (price) price.textContent = `1 ${fromToken} = 0.000000 ${toToken}`;
    const minReceived = document.getElementById("minReceived");
    if (minReceived) minReceived.textContent = `0.000000 ${toToken}`;
  }
};

// ==================== åˆå§‹åŒ–åº”ç”¨ ====================
document.addEventListener('DOMContentLoaded', function() {
  console.log('ğŸš€ LOMswap åˆå§‹åŒ–');
  
  EventHandlers.init();
  
  // ç›‘å¬é’±åŒ…äº‹ä»¶
  if (window.ethereum) {
    window.ethereum.on('accountsChanged', (accounts) => {
      if (accounts.length === 0) {
        AppCore.disconnect();
      } else {
        account = accounts[0];
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        AppCore.initContracts();
        AppCore.restoreInviteAddress();
        AppCore.updateUI();
        DataManager.refreshAll();
        LPRewardManager.refreshAll();
        LPRewardManager.startAutoRefresh();
        if (!refreshInterval) {
          refreshInterval = setInterval(() => {
            DataManager.refreshAll();
            if (document.getElementById('lpRewardTab').classList.contains('active')) {
              LPRewardManager.refreshAll();
            }
          }, 10000);
        }
      }
    });
    
    window.ethereum.on('chainChanged', () => {
      location.reload();
    });
    
    window.ethereum.on('disconnect', () => {
      AppCore.disconnect();
    });
    
    // æ£€æŸ¥æ˜¯å¦å·²è¿æ¥é’±åŒ…
    window.ethereum.request({ method: 'eth_accounts' }).then(accounts => {
      if (accounts.length > 0) {
        account = accounts[0];
        provider = new ethers.providers.Web3Provider(window.ethereum);
        signer = provider.getSigner();
        AppCore.initContracts();
        AppCore.restoreInviteAddress();
        AppCore.updateUI();
        DataManager.refreshAll();
        LPRewardManager.refreshAll();
        LPRewardManager.startAutoRefresh();
        
        if (!refreshInterval) {
          refreshInterval = setInterval(() => {
            DataManager.refreshAll();
            if (document.getElementById('lpRewardTab').classList.contains('active')) {
              LPRewardManager.refreshAll();
            }
          }, 10000);
        }
      }
    }).catch(console.error);
  }
});
</script>
</body>
</html>
